{"version":3,"file":"senpai-stage.js","sources":["../src/matrix/index.ts","../src/ease/consts.ts","../src/ease/index.ts","../src/util/index.ts","../src/view/Sprite.ts","../src/view/Button.ts","../src/view/Character.ts","../src/view/Checkbox.ts","../src/view/Close.ts","../src/view/Container.ts","../src/view/InteractionManager.ts","../src/view/Label.ts","../src/view/Panel.ts","../src/view/SFXSprite.ts","../src/view/Slider.ts","../src/view/Stage.ts","../src/view/Textbox.ts"],"sourcesContent":["import { IInteractionPoint } from \"../util\";\n\nexport interface IMatrix {\n  value: number[] | Float64Array;\n  immutable: boolean;\n  translate(x: number, y: number): IMatrix;\n  scale(x: number, y: number): IMatrix;\n  rotate(angle: number): IMatrix;\n  skewX(angle: number): IMatrix;\n  skewY(angle: number): IMatrix;\n  transform(props: Float64Array | number[]): IMatrix;\n  inverse(): IMatrix;\n  reset(): IMatrix;\n  set(target: Float64Array | number[]): IMatrix;\n}\n\nexport class Matrix implements IMatrix {\n  public value: number[] | Float64Array = new Float64Array(Identity);\n  public immutable: boolean = false;\n\n  constructor(value?: number[] | Float64Array, immutable?: boolean) {\n    this.value = value || new Float64Array(Identity);\n    this.immutable = immutable || this.immutable;\n  }\n\n  public translate(x: number, y: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      translate(x, y, this.value, m.value);\n      return m;\n    }\n\n    translate(x, y, this.value, this.value);\n    return this;\n  }\n\n  public scale(x: number, y: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      scale(x, y, this.value, m.value);\n      return m;\n    }\n\n    scale(x, y, this.value, this.value);\n    return this;\n  }\n\n  public rotate(angle: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      rotate(angle, this.value, m.value);\n      return m;\n    }\n\n    rotate(angle, this.value, this.value);\n    return this;\n  }\n\n  public skewX(angle: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      skewX(angle, this.value, m.value);\n      return m;\n    }\n\n    skewX(angle, this.value, this.value);\n    return this;\n  }\n\n  public skewY(angle: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      skewY(angle, this.value, m.value);\n      return m;\n    }\n\n    skewY(angle, this.value, this.value);\n    return this;\n  }\n\n  public transform(props: Float64Array | number[]): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      transform(this.value, props, m.value);\n      return m;\n    }\n    transform(this.value, props, this.value);\n    return this;\n  }\n\n  public reset(): IMatrix {\n    if (this.immutable) {\n      return chain();\n    }\n    reset(this.value);\n    return this;\n  }\n\n  public set(target: Float64Array | number[]): IMatrix {\n    set(target, this.value);\n    return this;\n  }\n\n  public inverse(): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      inverse(this.value, m.value);\n      return m;\n    }\n\n    inverse(this.value, this.value);\n    return this;\n  }\n}\n\nexport function inverse(\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  const a: number = matrix[0];\n  const b: number = matrix[1];\n  const c: number = matrix[2];\n  const d: number = matrix[3];\n  const e: number = matrix[4];\n  const f: number = matrix[5];\n  const det: number = 1 / (a * d - c * b);\n\n  setMatrix[0] = d * det;\n  setMatrix[1] = -b * det;\n  setMatrix[2] = -c * det;\n  setMatrix[3] = a * det;\n  setMatrix[4] = (c * f - e * d) * det;\n  setMatrix[5] = (e * b - a * f) * det;\n}\n\nexport const Identity = new Float64Array([1, 0, 0, 1, 0, 0]);\nexport const IdentityMatrix = new Matrix(Identity, true);\n\nexport function translate(\n  x: number,\n  y: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  setMatrix[0] = matrix[0];\n  setMatrix[1] = matrix[1];\n  setMatrix[2] = matrix[2];\n  setMatrix[3] = matrix[3];\n  setMatrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];\n  setMatrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];\n}\n\nexport function scale(\n  x: number,\n  y: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  setMatrix[0] = matrix[0] * x;\n  setMatrix[1] = matrix[1] * x;\n  setMatrix[2] = matrix[2] * y;\n  setMatrix[3] = matrix[3] * y;\n  setMatrix[4] = matrix[4];\n  setMatrix[5] = matrix[5];\n}\n\nexport function rotate(\n  angle: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const a = matrix[0];\n  const b = matrix[1];\n  const c = matrix[2];\n  const d = matrix[3];\n\n  setMatrix[0] = a * cos + c * sin;\n  setMatrix[1] = b * cos + d * sin;\n  setMatrix[2] = c * cos - a * sin;\n  setMatrix[3] = d * cos - b * sin;\n  setMatrix[4] = matrix[4];\n  setMatrix[5] = matrix[5];\n}\n\nexport function skewX(\n  angle: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  const tan = Math.tan(angle);\n\n  setMatrix[0] = matrix[0];\n  setMatrix[1] = matrix[1];\n  setMatrix[2] = matrix[2] + matrix[0] * tan;\n  setMatrix[3] = matrix[3] + matrix[1] * tan;\n  setMatrix[4] = matrix[4];\n  setMatrix[5] = matrix[5];\n}\n\nexport function skewY(\n  angle: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  const tan = Math.tan(angle);\n\n  setMatrix[0] = matrix[0] + matrix[2] * tan;\n  setMatrix[1] = matrix[1] + matrix[3] * tan;\n  setMatrix[2] = matrix[2];\n  setMatrix[3] = matrix[3];\n  setMatrix[4] = matrix[4];\n  setMatrix[5] = matrix[5];\n}\n\nexport function transform(\n  matrix: Float64Array | number[],\n  props: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  // props values\n  const pa = props[0];\n  const pb = props[1];\n  const pc = props[2];\n  const pd = props[3];\n  const pe = props[4];\n  const pf = props[5];\n\n  // matrix values\n  const ma = matrix[0];\n  const mb = matrix[1];\n  const mc = matrix[2];\n  const md = matrix[3];\n  const me = matrix[4];\n  const mf = matrix[5];\n\n  setMatrix[0] = ma * pa + mc * pb;\n  setMatrix[1] = mb * pa + md * pb;\n  setMatrix[2] = ma * pc + mc * pd;\n  setMatrix[3] = mb * pc + md * pd;\n  setMatrix[4] = ma * pe + mc * pf + me;\n  setMatrix[5] = mb * pe + md * pf + mf;\n}\n\nexport function transformPoints(\n  points: IInteractionPoint[],\n  matrix: Float64Array | number[],\n): void {\n  for (const point of points) {\n    transformPoint(point, matrix);\n  }\n}\n\nexport function transformPoint(point: IInteractionPoint, matrix: Float64Array | number[]): void {\n  point.tx = matrix[0] * point.x + matrix[2] * point.y + matrix[4];\n  point.ty = matrix[1] * point.x + matrix[3] * point.y + matrix[5];\n}\n\nexport function set(target: Float64Array | number[], source: Float64Array | number[]): void {\n  for (let i = 0; i < target.length && i < source.length; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function reset(target: Float64Array | number[]): void {\n  return set(target, [1, 0, 0, 1, 0, 0]);\n}\n\nexport function chain(\n  value: Float64Array | number[] = Identity,\n  immutable: boolean = false,\n): IMatrix {\n  return new Matrix(value, immutable);\n}\n","export const PI = Math.PI;\nexport const TAU = 2 * PI;\n","/****\n * Custom ease functions, designed with functional programming concepts.\n */\nimport { PI, TAU } from \"./consts\";\n\nfunction inverse(inFunc: (ratio: number) => number): (ratio: number) => number {\n  return function outFunc(ratio: number): number {\n    return 1 - inFunc(1 - ratio);\n  };\n}\n\nfunction inOut(inFunc: (ratio: number) => number): (ratio: number) => number {\n  const outFunc = inverse(inFunc);\n  return (ratio: number): number => ratio < 0.5\n    ? 0.5 * inFunc(ratio * 2)\n    : 0.5 + 0.5 * outFunc(2 * ratio - 1);\n}\n\nexport const easeLinear: (ratio: number) => number = function linear(ratio: number): number {\n  return ratio;\n};\n\nexport const easeInQuad: (ratio: number) => number = (ratio: number): number => ratio * ratio;\nexport const easeOutQuad: (ratio: number) => number = inverse(easeInQuad);\nexport const easeInOutQuad: (ratio: number) => number = inOut(easeInQuad);\n\nexport const easeInCub: (ratio: number) => number =\n  (ratio: number): number => ratio * ratio * ratio;\nexport const easeOutCub: (ratio: number) => number = inverse(easeInCub);\nexport const easeInOutCub: (ratio: number) => number = inOut(easeInCub);\n\nexport const easeInQuart: (ratio: number) => number =\n  (ratio: number): number => ratio * ratio * ratio * ratio;\nexport const easeOutQuart: (ratio: number) => number = inverse(easeInQuart);\nexport const easeInOutQuart: (ratio: number) => number = inOut(easeInQuart);\n\nexport const easeInQuint: (ratio: number) => number =\n  (ratio: number): number => ratio * ratio * ratio * ratio * ratio;\nexport const easeOutQuint: (ratio: number) => number = inverse(easeInQuint);\nexport const easeInOutQuint: (ratio: number) => number = inOut(easeInQuint);\n\nexport const easeOutSin: (ratio: number) => number =\n  (ratio: number): number => Math.sin(ratio * PI * 0.5);\nexport const easeInSin: (ratio: number) => number = inverse(easeOutSin);\nexport const easeInOutSin: (ratio: number) => number = inOut(easeInSin);\n\nconst p = 0.3;\nexport const easeOutElastic: (ratio: number) => number =\n  (ratio: number): number => Math.pow(2, -10 * ratio) * Math.sin((ratio - p / 4) * TAU / p) + 1;\nexport const easeInElastic: (ratio: number) => number = inverse(easeOutElastic);\nexport const easeInOutElastic: (ratio: number) => number = inOut(easeInElastic);\n","import { ISprite } from \"../view/Sprite\";\n\nexport interface IPoint {\n  x: number;\n  y: number;\n}\n\nexport interface ISpriteSheet {\n  frames: ISpriteSheetFrameMap;\n  meta: ISpriteSheetMeta;\n}\n\nexport interface ISpriteSheetFrameMap {\n  [frame: string]: ISpriteSheetFrame;\n}\n\nexport interface ISpriteSheetMeta {\n  app: string;\n  version: string;\n  image: string;\n  size: ISpriteSheetSize;\n  scale: number;\n}\n\nexport interface ISpriteSheetFrame {\n  frame: ISpriteSheetPoint & ISpriteSheetSize;\n  rotated: boolean;\n  trimmed: boolean;\n  spriteSourceSize: ISpriteSheetPoint & ISpriteSheetSize;\n  sourceSize: ISpriteSheetSize;\n}\n\nexport interface ISpriteSheetSize {\n  w: number;\n  h: number;\n}\n\nexport interface ISpriteSheetPoint {\n  x: number;\n  y: number;\n}\n\nexport interface ITextureMap {\n  [texture: string]: ImageBitmap;\n}\n\nexport interface IInteractionPoint extends IPoint {\n  id: string;\n  type: \"Touch\" | \"Mouse\";\n  down: boolean;\n  clicked: boolean;\n  captured: boolean;\n  active: ISprite;\n  hover: ISprite;\n  firstDown: boolean;\n  tx: number;\n  ty: number;\n}\n\nexport interface IPlayable {\n  started: number; // timestamp when the media last began playing\n  length: number; // media play length timespan\n  start: number; // media start time\n  end: number; // media end time\n  loop: boolean; // does this media loop?\n  state: PlayState; // self explainatory\n  loaded: Promise<void>; // this should be a promise that resolves once the audio has loaded\n  play(): this;\n  pause(): this;\n  stop(): this;\n  setVolume(volume: number); // accepts number [0. 1]\n}\n\nexport interface IAudio extends IPlayable {\n  gain: GainNode; // controls volume\n  source: AudioBuffer; // is null until the audioBuffer is loaded\n  destination: AudioNode;\n  definition: ISoundSpriteSheet; // this will be the provided sound sprite sheet\n  context: AudioContext; // provided audio context for creating the sound sprite\n}\n\nexport interface ISoundSpriteSheet {\n  resources: string[];\n  spritemap: {\n    [name: string]: ISoundSpriteSheetTexture;\n  };\n}\n\nexport interface ISoundSpriteSheetTexture {\n  start: number;\n  end: number;\n  loop: boolean;\n}\n\nexport interface IAudioProps extends IPlayableProps {\n  definition: ISoundSpriteSheet; // this will be the provided sound sprite sheet\n  context: AudioContext; // provided audio context for creating the sound sprite\n  name: string; // determines the name of the audio clip\n}\n\nexport interface IPlayableProps {\n  source: Promise<Response>;\n  texture: string; // this should be name of the texture in the spritesheet\n}\n\nexport interface IKeyState {\n  key: string;\n  down: boolean;\n}\n\nexport interface ISize {\n  width: number;\n  height: number;\n}\n\nexport interface IPadding {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n}\n\nexport async function createTextureMap(definition: ISpriteSheet, img: Promise<ImageBitmap>) {\n  const textures: ITextureMap = {};\n  await Promise.all(\n    Object.entries(definition.frames).map(async ([desc, frame], i) => {\n      textures[desc] = await createImageBitmap(\n        await img,\n        frame.frame.x,\n        frame.frame.y,\n        frame.frame.w,\n        frame.frame.h,\n      );\n    }),\n  );\n  return textures;\n}\n\nexport async function loadImage(src: string): Promise<ImageBitmap> {\n  const res = await fetch(src);\n  const blob = await res.blob();\n  const bmp = await createImageBitmap(blob);\n  return bmp;\n}\n\nexport function zSort(left: ISprite, right: ISprite): number {\n  return left.z - right.z;\n}\n\nexport enum TextAlign {\n  \"left\" = \"left\",\n  \"right\" = \"right\",\n  \"center\" = \"center\",\n  \"start\" = \"start\",\n  \"end\" = \"end\",\n}\n\nexport enum TextBaseline {\n  \"top\" = \"top\",\n  \"hanging\" = \"hanging\",\n  \"middle\" = \"middle\",\n  \"alphabetic\" = \"alphabetic\",\n  \"ideographic\" = \"ideographic\",\n  \"bottom\" = \"bottom\",\n}\n\nexport enum PlayState {\n  Playing,\n    Paused,\n    Stopped,\n}\n","import assert from \"assert\";\nimport { EventEmitter } from \"events\";\nimport * as eases from \"../ease\";\nimport * as m from \"../matrix\";\nimport { ISpriteSheet, createTextureMap, IInteractionPoint, IKeyState, ISize, ITextureMap, loadImage } from \"../util\";\nimport { IStage } from \"./Stage\";\n\nexport interface ISprite extends ISize {\n  id: string;\n  parent: IStage | ISprite;\n\n  // position\n\n  previousPosition: Float64Array;\n  position: Float64Array;\n  inverse: Float64Array;\n  alpha: number;\n  interpolatedAlpha: number;\n  previousAlpha: number;\n  z: number;\n\n  // animation\n\n  lastInterpolated: number;\n  interpolatedPosition: Float64Array;\n  animationStart: number;\n  animationLength: number;\n  wait: number;\n  // stage properties\n\n  active: boolean;\n  hover: boolean;\n  down: boolean;\n  cursor: \"pointer\" | \"default\";\n  loaded: Promise<void>;\n\n  texture: ImageBitmap | HTMLCanvasElement | HTMLImageElement;\n\n  // this is set by the over function\n  ease(ratio: number): number;\n\n  broadPhase(point: IInteractionPoint): boolean;\n  narrowPhase(point: IInteractionPoint): ISprite;\n  isHovering(point: IInteractionPoint, now: number): ISprite;\n  pointCollision(point: IInteractionPoint): boolean;\n  keyStateChange(key: IKeyState): void;\n  setTexture(texture: string): this;\n  over(timespan: number, wait: number, ease: (ratio: number) => number): this;\n  move(position: number[] | Float64Array): this;\n  setZ(z: number): this;\n  setAlpha(alpha: number): this;\n  interpolate(now: number): void;\n  skipAnimation(now: number): boolean;\n  update(): void;\n  render(ctx: CanvasRenderingContext2D): void;\n  emit(event: string, ...args: any[]): boolean;\n\n  on(event: \"point-move\", callback: (sprite: ISprite, point: IInteractionPoint) => void);\n  on(event: string, callback: () => void): this;\n\n  on(event: \"point-move\", callback: (sprite: ISprite, point: IInteractionPoint) => void);\n  once(event: string, callback: () => void): this;\n\n  removeAllListeners(event: string | symbol): this;\n  eventNames(): Array<string | symbol>;\n}\n\nexport interface ISpriteProps {\n  id: string;\n  position: Float64Array | number[];\n  textures?: ITextureMap;\n  alpha?: number;\n  z?: number;\n  source: Promise<Response>;\n  definition: ISpriteSheet;\n}\n\nexport class Sprite extends EventEmitter implements ISprite {\n  public id: string = \"\";\n  public position: Float64Array = new Float64Array(6);\n  public previousPosition: Float64Array = new Float64Array(6);\n  public interpolatedPosition: Float64Array = new Float64Array(6);\n  public inverse: Float64Array = new Float64Array(6);\n  public alpha: number = 1;\n  public interpolatedAlpha: number = 1;\n  public previousAlpha: number = 1;\n  public z: number = 0;\n  public parent: ISprite = null;\n  public wait: number = 0;\n\n  public lastInterpolated: number = 0;\n  public animationStart: number = 0;\n  public ease = eases.easeLinear;\n  public cursor: (\"pointer\" | \"default\") = \"default\";\n  public animationLength: number = 0;\n  public active: boolean = false;\n  public hover: boolean = false;\n  public down: boolean = false;\n  public textures: ITextureMap = {};\n  public texture: ImageBitmap | HTMLCanvasElement | HTMLImageElement = new Image();\n  public loaded : Promise<void> = null;\n\n  public width: number = 0;\n  public height: number = 0;\n\n  constructor(props: ISpriteProps) {\n    super();\n    this.id = props.id;\n    const position = props.position || m.Identity;\n    this.textures = props.textures ? props.textures : this.textures;\n    m.set(this.position, position);\n    m.set(this.previousPosition, position);\n    m.set(this.interpolatedPosition, position);\n\n    if (props.hasOwnProperty(\"alpha\")) {\n      this.previousAlpha = this.alpha = this.interpolatedAlpha = props.alpha;\n    }\n    if (props.hasOwnProperty(\"z\")) {\n      this.z = props.z;\n    }\n    this.loaded = props.source ? this.loadTexture(props.source, props.definition) : Promise.resolve();\n  }\n\n  public broadPhase(point: IInteractionPoint): boolean {\n    return point.tx >= 0 && point.tx <= this.width && point.ty >= 0 && point.ty <= this.height;\n  }\n\n  public narrowPhase(point: IInteractionPoint): ISprite {\n    return this;\n  }\n\n  public pointCollision(point: IInteractionPoint): boolean {\n    return true;\n  }\n\n  public isHovering(point: IInteractionPoint, now: number): ISprite {\n    this.interpolate(now);\n    m.transformPoint(point, this.inverse);\n    if (this.broadPhase(point)) {\n      return this.narrowPhase(point);\n    }\n  }\n\n  public move(position: number[] | Float64Array): this {\n    this.previousPosition[0] = this.interpolatedPosition[0];\n    this.previousPosition[1] = this.interpolatedPosition[1];\n    this.previousPosition[2] = this.interpolatedPosition[2];\n    this.previousPosition[3] = this.interpolatedPosition[3];\n    this.previousPosition[4] = this.interpolatedPosition[4];\n    this.previousPosition[5] = this.interpolatedPosition[5];\n\n    this.position[0] = position[0];\n    this.position[1] = position[1];\n    this.position[2] = position[2];\n    this.position[3] = position[3];\n    this.position[4] = position[4];\n    this.position[5] = position[5];\n    return this;\n  }\n\n  public setAlpha(alpha: number): this {\n    this.previousAlpha = this.interpolatedAlpha;\n    this.alpha = alpha;\n    return this;\n  }\n\n  public setZ(z: number): this {\n    this.z = z;\n    return this;\n  }\n\n  public over(timespan: number, wait: number = 0, ease: (ratio: number) => number = this.ease): this {\n    this.animationLength = timespan;\n    this.animationStart = Date.now();\n    this.ease = ease || this.ease;\n    this.wait = wait;\n    return this;\n  }\n\n  public keyStateChange(key: IKeyState): void {\n    throw new Error(\"Not implemented.\");\n  }\n\n  public skipAnimation(now: number): boolean {\n    const result: boolean = now < this.animationLength + this.animationStart;\n    this.animationStart = now - this.animationLength;\n    return result;\n  }\n\n  public update(): void {\n    // No op\n  }\n  public interpolate(now: number): void {\n    if (now <= this.lastInterpolated) {\n      return;\n    }\n    this.lastInterpolated = now;\n\n    const progress = now - (this.animationStart + this.wait);\n\n    const ratio = (progress >= this.animationLength)\n        ? 1\n        : (progress <= 0 ? 0 : this.ease(progress / this.animationLength));\n\n    if (ratio === 1) {\n      this.interpolatedPosition[0] = this.position[0];\n      this.interpolatedPosition[1] = this.position[1];\n      this.interpolatedPosition[2] = this.position[2];\n      this.interpolatedPosition[3] = this.position[3];\n      this.interpolatedPosition[4] = this.position[4];\n      this.interpolatedPosition[5] = this.position[5];\n      this.interpolatedAlpha = this.alpha;\n    } else if (ratio === 0) {\n      this.interpolatedPosition[0] = this.previousPosition[0];\n      this.interpolatedPosition[1] = this.previousPosition[1];\n      this.interpolatedPosition[2] = this.previousPosition[2];\n      this.interpolatedPosition[3] = this.previousPosition[3];\n      this.interpolatedPosition[4] = this.previousPosition[4];\n      this.interpolatedPosition[5] = this.previousPosition[5];\n      this.interpolatedAlpha = this.previousAlpha;\n    } else {\n      for (let j = 0; j < 6; j++) {\n        this.interpolatedPosition[j] = this.previousPosition[j]\n          + ratio * (this.position[j] - this.previousPosition[j]);\n      }\n      this.interpolatedAlpha = this.previousAlpha + ratio * (this.alpha - this.previousAlpha);\n    }\n\n    m.inverse(this.interpolatedPosition, this.inverse);\n\n    if (this.parent) {\n      this.parent.interpolate(now);\n\n      m.chain(this.parent.inverse, true)\n        .transform(this.inverse)\n        .set(this.inverse);\n    }\n  }\n  public setTexture(texture: string): this {\n    const oldTexture = this.texture;\n    this.texture = this.textures[texture];\n    this.width = this.texture.width;\n    this.height = this.texture.height;\n\n    if (oldTexture !== this.texture) {\n      this.emit(\"texture-change\", this.texture);\n    }\n\n    return this;\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    ctx.drawImage(this.texture, 0, 0);\n  }\n\n  private async loadTexture(res: Promise<Response>, definition: ISpriteSheet) : Promise<void> {\n    const resp = await res;\n    const blob = await resp.blob();\n    this.textures = await createTextureMap(definition, createImageBitmap(blob));\n  }\n}\n\nexport interface ILoadSpriteProps extends ISpriteProps {\n\n}\n","import { createTextureMap,  ITextureMap, loadImage, TextAlign, TextBaseline } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nimport assert from \"assert\";\n\nexport interface IButton extends ISprite {\n  selected: boolean;\n  font: string;\n  fontColor: string;\n  fontSize: number;\n  text: string;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n  setText(text: string): this;\n}\n\nexport interface IButtonProps extends ISpriteProps {\n  selected?: boolean;\n  font?: string;\n  fontColor?: string;\n  fontSize?: number;\n  text?: string;\n  textAlign?: TextAlign;\n  textBaseline?: TextBaseline;\n}\n\nexport class Button extends Sprite implements IButton {\n  public selected: boolean = false;\n  public font: string = \"monospace\";\n  public fontColor: string = \"black\";\n  public fontSize: number = 12;\n  public text: string =  \"\";\n  public textAlign: TextAlign = TextAlign.center;\n  public textBaseline: TextBaseline = TextBaseline.middle;\n\n  constructor(props: IButtonProps) {\n    super(props);\n    this.selected = props.selected || false;\n    this.font = props.font || this.font;\n    this.fontColor = props.fontColor || this.fontColor;\n    this.fontSize = props.fontSize || this.fontSize;\n    this.text = props.text || this.text;\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n\n  public update(): void {\n    const active = this.active ? \"Active\" : \"Inactive\";\n    const hover = this.hover ? \"Hover\" : \"NoHover\";\n    const selected = this.selected ? \"Selected\" : \"Unselected\";\n    this.setTexture(`${active}_${hover}_${selected}`);\n\n    this.cursor = this.hover ? \"pointer\" : \"default\";\n    super.update();\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    super.render(ctx);\n    ctx.translate(this.texture.width * 0.5, this.texture.height * 0.5);\n    ctx.textBaseline = TextBaseline.middle;\n    ctx.textAlign = TextAlign.center;\n    ctx.font = `${this.fontSize}px ${this.font}`;\n    ctx.fillStyle = this.fontColor;\n    ctx.fillText(this.text, 0, 0);\n  }\n\n  public setText(text: string): this {\n    this.text = text;\n    return this;\n  }\n}\n\nexport interface ILoadButtonProps extends IButtonProps {\n\n}\n","import assert from \"assert\";\nimport { createTextureMap, loadImage } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface ICharacterProps extends ISpriteProps {\n  name: string;\n  displayName: string;\n  color: string;\n}\n\nexport interface ICharacter extends ISprite {\n  name: string;\n  displayName: string;\n  color: string;\n}\n\nexport class Character extends Sprite implements ICharacter {\n  public name: string = \"\";\n  public displayName: string = \"\";\n  public color: string = \"\";\n  constructor(props: ICharacterProps) {\n    super(props);\n    this.name = props.name;\n    this.displayName = props.displayName;\n    this.color = props.color;\n  }\n}\n\nexport interface ILoadCharacterProps extends ICharacterProps {\n\n}\n","import assert from \"assert\";\nimport {\n  createTextureMap,\n  IInteractionPoint,\n  ITextureMap,\n  loadImage,\n  TextAlign,\n  TextBaseline,\n} from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface ICheckbox extends ISprite {\n  checked: boolean;\n  text: string;\n  font: string;\n  fontColor: string;\n  fontSize: number;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n\n  setText(text: string): this;\n  toggle(): this;\n}\n\nexport interface ICheckboxProps extends ISpriteProps {\n  checked?: boolean;\n  text?: string;\n  font?: string;\n  fontColor?: string;\n  fontSize?: number;\n  textAlign?: TextAlign;\n  textBaseline?: TextBaseline;\n}\n\nexport class Checkbox extends Sprite implements ICheckbox {\n  public checked: boolean = false;\n  public text: string = \"\";\n  public font: string = \"monospace\";\n  public fontColor: string = \"black\";\n  public fontSize: number = 12;\n  public textAlign: TextAlign = TextAlign.left;\n  public textBaseline: TextBaseline = TextBaseline.middle;\n\n  constructor(props: ICheckboxProps) {\n    super(props);\n    this.checked = Boolean(props.checked) || false;\n    this.text = props.text || this.text;\n    this.font = props.font || this.font;\n    this.fontColor = props.fontColor || this.fontColor;\n    this.textAlign = props.textAlign || this.textAlign;\n    this.textBaseline = props.textBaseline || this.textBaseline;\n  }\n\n  public toggle(): this {\n    this.checked = !this.checked;\n    return this;\n  }\n\n  public pointCollision(point: IInteractionPoint): boolean {\n    if (point.clicked && point.active === this) {\n      this.toggle();\n      this.emit(\"toggle\", point);\n    }\n    return super.pointCollision(point);\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    super.render(ctx);\n    ctx.translate(this.width * 1.1, this.height / 2);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    ctx.fillStyle = this.fontColor;\n    ctx.font = `${this.fontSize}px ${this.font}`;\n    ctx.fillText(this.text, 0, 0);\n  }\n\n  public update(): void {\n    const active = this.active ? \"Active\" : \"Inactive\";\n    const hover = this.hover ? \"Hover\" : \"NoHover\";\n    const checked = this.checked ? \"Checked\" : \"Unchecked\";\n    this.setTexture(`${active}_${hover}_${checked}`);\n\n    this.cursor = this.hover ? \"pointer\" : \"default\";\n    super.update();\n  }\n\n  public setText(text: string): this {\n    this.text = text;\n    return this;\n  }\n}\n\nexport interface ILoadCheckboxProps extends ICheckboxProps {\n\n}\n","import assert from \"assert\";\nimport { createTextureMap, ITextureMap, loadImage } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface IClose extends ISprite {\n\n}\n\nexport interface ICloseProps extends ISpriteProps {\n\n}\n\nexport class Close extends Sprite implements IClose {\n  constructor(props: ICloseProps) {\n    super(props);\n  }\n  public update(): void {\n    const active = this.active ? \"Active\" : \"Inactive\";\n    const hover = this.hover ? \"Hover\" : \"NoHover\";\n    this.setTexture(`${active}_${hover}`);\n\n    this.cursor = this.hover ? \"pointer\" : \"default\";\n    super.update();\n  }\n}\n\nexport interface ILoadCloseProps extends ICloseProps {\n\n}\n","import { EventEmitter } from \"events\";\nimport { IInteractionPoint, IPlayable } from \"../util\";\nimport { ISprite } from \"./Sprite\";\n\nexport interface IContainer {\n  sprites: ISprite[];\n  playables: IPlayable[];\n  points: IInteractionPoint[];\n  audioContext: AudioContext;\n\n  addSprite(sprite: ISprite): this;\n  removeSprite(sprite: ISprite): this;\n  addPlayable(sprite: IPlayable): this;\n  removePlayable(sprite: IPlayable): this;\n  addPoint(point: IInteractionPoint): this;\n  removePoint(point: IInteractionPoint): this;\n}\n\nexport interface IContainerProps {\n  audioContext: AudioContext;\n}\n\nexport class Container extends EventEmitter implements IContainer {\n\n  public sprites: ISprite[] = [];\n  public playables: IPlayable[] = [];\n  public points: IInteractionPoint[] = [];\n  public audioContext: AudioContext = null;\n\n  constructor(props: IContainerProps) {\n    super();\n    this.audioContext = props.audioContext || new AudioContext();\n  }\n\n  public addSprite(sprite: ISprite): this {\n    if (!this.sprites.includes(sprite)) {\n      this.sprites.push(sprite);\n    }\n    return this;\n  }\n\n  public removeSprite(sprite: ISprite): this {\n    if (this.sprites.includes(sprite)) {\n      this.sprites.splice(this.sprites.indexOf(sprite), 1);\n    }\n    return this;\n  }\n\n  public addPlayable(sprite: IPlayable): this {\n    if (!this.playables.includes(sprite)) {\n      this.playables.push(sprite);\n      // NOTE: This may be audio specific?\n      //      sprite.gain.connect(this.audioContext.destination);\n    }\n    return this;\n  }\n\n  public removePlayable(sprite: IPlayable): this {\n    if (this.playables.includes(sprite)) {\n      this.playables.splice(this.playables.indexOf(sprite), 1);\n      // NOTE: This may be audio specific?\n      //      sprite.gain.disconnect(this.audioContext.destination);\n    }\n    return this;\n  }\n\n  public addPoint(point: IInteractionPoint): this {\n    if (!this.points.includes(point)) {\n      this.points.push(point);\n    }\n    return this;\n  }\n\n  public removePoint(point: IInteractionPoint): this {\n    if (this.points.includes(point)) {\n      this.points.splice(this.points.indexOf(point), 1);\n    }\n    return this;\n  }\n}\n","import { transformPoint } from \"../matrix\";\nimport { IInteractionPoint, zSort } from \"../util\";\nimport { Container, IContainer, IContainerProps } from \"./Container\";\nimport { ISprite } from \"./Sprite\";\n\ninterface IInteractionPointIndex {\n  [id: number]: IInteractionPoint;\n}\n\nexport interface IInteractionManager extends IContainer {\n  canvas: HTMLCanvasElement;\n  mousePoint: IInteractionPoint;\n  touchPointIndex: IInteractionPointIndex;\n\n  hookEvents(): void;\n  dispose(): void;\n  addTouchPoint(touch: Touch): IInteractionPoint;\n  removeTouchPoint(touch: Touch): void;\n  pointDown(point: IInteractionPoint, position: Touch | MouseEvent): void;\n  pointUp(point: IInteractionPoint, position: Touch | MouseEvent): void;\n  pointMove(point: IInteractionPoint, position: Touch | MouseEvent): void;\n  pointCancel(point: IInteractionPoint, position: Touch | MouseEvent): void;\n\n  // high level events\n  mouseDown(event: MouseEvent): void;\n  mouseUp(event: MouseEvent): void;\n  mouseMove(event: MouseEvent): void;\n  touchStart(event: TouchEvent): void;\n  touchEnd(event: TouchEvent): void;\n  touchMove(event: TouchEvent): void;\n  touchCancel(event: TouchEvent): void;\n}\n\ninterface IInteractionPointEvent {\n  target: HTMLElement;\n  event: string;\n  listener: (e: MouseEvent | TouchEvent) => void;\n}\n\nexport interface IInteractionManagerProps extends IContainerProps {\n  canvas: HTMLCanvasElement;\n  width: number;\n  height: number;\n}\n\nexport class InteractionManager extends Container implements IInteractionManager {\n  public canvas: HTMLCanvasElement = null;\n  public ctx: CanvasRenderingContext2D = null;\n  public touchPointIndex: IInteractionPointIndex = {};\n  public mousePoint: IInteractionPoint = {\n    active: null,\n    captured: false,\n    clicked: false,\n    down: false,\n    firstDown: false,\n    hover: null,\n    id: \"mouse\",\n    tx: 0,\n    ty: 0,\n    type: \"Mouse\",\n    x: 0,\n    y: 0,\n  };\n  private events: IInteractionPointEvent[] = [\n    { target: null, event: \"mousedown\", listener: e => this.mouseDown(e as MouseEvent) },\n    { target: document.body, event: \"mouseup\", listener: e => this.mouseUp(e as MouseEvent) },\n    { target: null, event: \"mousemove\", listener: e => this.mouseMove(e as MouseEvent) },\n    { target: null, event: \"touchstart\", listener: e => this.touchStart(e as TouchEvent) },\n    { target: document.body, event: \"touchend\", listener: e => this.touchEnd(e as TouchEvent) },\n    { target: null, event: \"touchmove\", listener: e => this.touchMove(e as TouchEvent) },\n    { target: document.body, event: \"touchcancel\", listener: e => this.touchCancel(e as TouchEvent) },\n  ];\n\n  constructor(props: IInteractionManagerProps) {\n    super(props);\n    this.canvas = props.canvas;\n    if (!this.canvas) {\n      this.canvas = document.createElement(\"canvas\");\n      document.body.appendChild(this.canvas);\n    }\n    this.canvas.width = props.width;\n    this.canvas.height = props.height;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.hookEvents();\n    this.addPoint(this.mousePoint);\n  }\n\n  public hookEvents(): void {\n    this.events.forEach(\n      event => (event.target || this.canvas)\n        .addEventListener(event.event, event.listener),\n    );\n  }\n\n  public dispose(): void {\n    this.events.forEach(\n      event => (event.target || this.canvas)\n        .removeEventListener(event.event, event.listener),\n    );\n  }\n\n  public mouseDown(event: MouseEvent): void {\n    return this.pointDown(this.mousePoint, event);\n  }\n\n  public mouseUp(event: MouseEvent): void {\n    return this.pointUp(this.mousePoint, event);\n  }\n\n  public mouseMove(event: MouseEvent): void {\n    return this.pointMove(this.mousePoint, event);\n  }\n\n  public touchStart(event: TouchEvent): void {\n    let touch: Touch;\n    let point: IInteractionPoint;\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < event.changedTouches.length; i++) {\n      touch = event.changedTouches[i];\n      point = this.addTouchPoint(touch);\n      this.pointDown(point, touch);\n    }\n  }\n\n  public touchEnd(event: TouchEvent): void {\n    let touch: Touch = null;\n    let point: IInteractionPoint;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < event.changedTouches.length; i++) {\n      touch = event.changedTouches[i];\n      point = this.touchPointIndex[touch.identifier];\n      this.pointUp(point, touch);\n      this.removeTouchPoint(touch);\n    }\n  }\n\n  public touchCancel(event: TouchEvent): void {\n    let touch: Touch = null;\n    let point: IInteractionPoint;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < event.changedTouches.length; i++) {\n      touch = event.changedTouches[i];\n      point = this.touchPointIndex[touch.identifier];\n      this.pointCancel(point, touch);\n      this.removeTouchPoint(touch);\n    }\n  }\n\n  public touchMove(event: TouchEvent): void {\n    let touch: Touch = null;\n    let point: IInteractionPoint;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < event.changedTouches.length; i++) {\n      touch = event.changedTouches[i];\n      point = this.touchPointIndex[touch.identifier];\n      this.pointMove(point, touch);\n    }\n  }\n  public pointDown(point: IInteractionPoint, position: Touch | MouseEvent): void {\n    this.pointMove(point, position);\n    if (point.hover) {\n      point.active = point.hover;\n      point.active.down = true;\n      point.active.active = true;\n      point.active.emit(\"down\", point);\n    }\n    this.emit(\"firstdown\", point);\n  }\n\n  public pointUp(point: IInteractionPoint, position: Touch | MouseEvent): void {\n    this.pointMove(point, position);\n    if (point.active) {\n      point.active.emit(\"up\", point);\n    }\n    if (point.active && point.hover === point.active) {\n      point.active.emit(\"click\", point);\n      point.active.down = false;\n      point.active.active = false;\n      point.active = null;\n    }\n    this.emit(\"click\", point);\n  }\n\n  public pointMove(point: IInteractionPoint, position: Touch | MouseEvent): void {\n    const now = Date.now();\n    const rect = this.canvas.getBoundingClientRect();\n    point.x = position.clientX - rect.left;\n    point.y = position.clientY - rect.top;\n\n    if (point.hover) {\n      point.hover.hover = false;\n      point.hover = null;\n    }\n    this.sprites.sort(zSort);\n\n    let sprite: ISprite;\n    let hoveringSprite: ISprite;\n    for (let i = this.sprites.length - 1; i >= 0; i--) {\n      sprite = this.sprites[i];\n      hoveringSprite = sprite.isHovering(point, now);\n\n      if (hoveringSprite) {\n        hoveringSprite.hover = true;\n        point.hover = hoveringSprite;\n        hoveringSprite.pointCollision(point);\n        hoveringSprite.emit(\"point-move\", point);\n      }\n    }\n\n    super.emit(\"point-move\", point);\n  }\n\n  public pointCancel(point: IInteractionPoint, position: Touch | MouseEvent): void {\n    if (point.active) {\n      point.active.active = false;\n      point.active = null;\n    }\n    if (point.hover) {\n      point.hover.hover = false;\n      point.hover = null;\n    }\n  }\n\n  public addTouchPoint(touch: Touch): IInteractionPoint {\n    const point: IInteractionPoint = {\n      active: null,\n      captured: false,\n      clicked: false,\n      down: false,\n      firstDown: false,\n      hover: null,\n      id: touch.identifier.toString(),\n      tx: 0,\n      ty: 0,\n      type: \"Touch\",\n      x: 0,\n      y: 0,\n    };\n    this.touchPointIndex[touch.identifier] = point;\n    this.points.push(point);\n    return point;\n  }\n\n  public removeTouchPoint(touch: Touch): void {\n    const point: IInteractionPoint = this.touchPointIndex[touch.identifier];\n    delete this.touchPointIndex[touch.identifier];\n    this.removePoint(point);\n  }\n\n  public hoverCheck(now: number): void {\n    let point: IInteractionPoint;\n    let sprite: ISprite;\n\n    for (point of this.points) {\n      if (point.hover) {\n        point.hover.hover = false;\n        point.hover = null;\n      }\n\n      for (sprite of this.sprites) {\n        if (sprite.isHovering(point, now)) {\n          sprite.pointCollision(point);\n          point.hover = sprite;\n          sprite.hover = true;\n          break;\n        }\n      }\n    }\n  }\n}\n","import { TextAlign, TextBaseline } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface ILabel extends ISprite {\n  text: string;\n  font: string;\n  fontSize: number;\n  fontColor: string;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n  setText(text: string): this;\n}\n\nexport interface ILabelProps extends ISpriteProps {\n  text?: string;\n  font?: string;\n  fontSize?: number;\n  fontColor?: string;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n}\n\nconst tempctx = document.createElement(\"canvas\").getContext(\"2d\");\n\nexport class Label extends Sprite implements ILabel {\n  public text: string = \"\";\n  public font: string = \"monospace\";\n  public fontSize: number = 12;\n  public fontColor: string = \"black\";\n  public textAlign: TextAlign = TextAlign.start;\n  public textBaseline: TextBaseline = TextBaseline.hanging;\n\n  constructor(props: ILabelProps) {\n    super(props);\n    this.text = props.text || this.text;\n    this.font = props.font || this.font;\n    this.fontSize = props.fontSize || this.fontSize;\n    this.fontColor = props.fontColor || this.fontColor;\n    this.textBaseline = props.textBaseline || this.textBaseline;\n    this.textAlign = props.textAlign || this.textAlign;\n  }\n\n  public update(): void {\n    this.height = this.fontSize;\n    tempctx.font = `${this.fontSize}px ${this.font}`;\n    this.width = tempctx.measureText(this.text).width;\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    ctx.translate(this.texture.width * 0.5, this.texture.height * 0.5);\n    ctx.textBaseline = this.textBaseline;\n    ctx.textAlign = this.textAlign;\n    ctx.font = `${this.fontSize}px ${this.font}`;\n    ctx.fillStyle = this.fontColor;\n    ctx.fillText(this.text, 0, 0);\n  }\n\n  public setText(text: string): this {\n    this.text = text;\n    return this;\n  }\n}\n","import assert from \"assert\";\nimport { transformPoint } from \"../matrix\";\nimport { createTextureMap, IInteractionPoint, ITextureMap, loadImage } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nconst sortZ = (a: ISprite, b: ISprite): number => a.z - b.z;\n\nexport interface IPanel extends ISprite {\n  addSprite(sprite: ISprite): this;\n  removeSprite(sprite: ISprite): this;\n}\n\nexport interface IPanelProps extends ISpriteProps {\n  sprites?: ISprite[];\n}\n\nexport class Panel extends Sprite implements IPanel {\n  private sprites: ISprite[] = [];\n\n  constructor(props: IPanelProps) {\n    super(props);\n    this.sprites = props.sprites || this.sprites;\n  }\n\n  public addSprite(sprite: ISprite): this {\n    sprite.parent = this;\n    this.sprites.push(sprite);\n    return this;\n  }\n\n  public interpolate(now: number) {\n    if (now <= this.lastInterpolated) {\n      return;\n    }\n    super.interpolate(now);\n    for (const sprite of this.sprites) {\n      sprite.interpolate(now);\n    }\n  }\n\n  public removeSprite(sprite: ISprite): this {\n    if (this.sprites.includes(sprite)) {\n      this.sprites.splice(this.sprites.indexOf(sprite), 1);\n      sprite.parent = null;\n    }\n\n    return this;\n  }\n\n  public broadPhase(point: IInteractionPoint): boolean {\n    this.sprites.sort(sortZ);\n\n    for (const sprite of this.sprites) {\n      sprite.down = false;\n      sprite.hover = false;\n    }\n    return super.broadPhase(point);\n  }\n  public narrowPhase(point: IInteractionPoint): ISprite {\n    let sprite: ISprite = null;\n    let collision: ISprite = null;\n\n    for (let i = this.sprites.length - 1; i >= 0; i--) {\n      sprite = this.sprites[i];\n\n      // the sprites inverse has already been calculated relative to the parent\n      transformPoint(point, sprite.inverse);\n\n      if (!sprite.broadPhase(point)) {\n        continue;\n      }\n\n      collision = sprite.narrowPhase(point);\n      if (collision) {\n        return collision;\n      }\n    }\n    return this;\n  }\n  public update(): void {\n    this.hover = false;\n    for (const sprite of this.sprites) {\n      sprite.update();\n\n      if (sprite.hover) {\n        this.hover = sprite.hover;\n        this.cursor = sprite.cursor;\n      }\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    super.render(ctx);\n\n    ctx.beginPath();\n    ctx.rect(0, 0, this.width, this.height);\n    ctx.clip();\n\n    for (const sprite of this.sprites) {\n      ctx.save();\n      ctx.transform(\n        sprite.interpolatedPosition[0],\n        sprite.interpolatedPosition[1],\n        sprite.interpolatedPosition[2],\n        sprite.interpolatedPosition[3],\n        sprite.interpolatedPosition[4],\n        sprite.interpolatedPosition[5],\n      );\n      ctx.globalAlpha *= sprite.interpolatedAlpha;\n      sprite.render(ctx);\n      ctx.restore();\n    }\n  }\n\n  public skipAnimation(now: number): boolean {\n    let result: boolean = super.skipAnimation(now);\n    for (const sprite of this.sprites) {\n      result = sprite.skipAnimation(now) || result;\n    }\n    return result;\n  }\n}\n\nexport interface ILoadPanelProps extends IPanelProps {\n\n}\n","import {IAudio, IAudioProps, ISoundSpriteSheet, PlayState } from \"../util\";\n\nexport interface ISFX extends IAudio {\n  loop: false; // it will always be false\n}\n\nexport interface ISFXProps extends IAudioProps {\n}\n\nexport interface ILoadSFXProps {\n  name: string;\n  texture: string;\n}\n\nexport class SFXSprite implements ISFX {\n\n  // fields from IPlayable\n  public started: number = 0;\n  public length: number = 0;\n  public start: number = 0;\n  public end: number = 0;\n  public loop: false = false;\n  public state: PlayState = PlayState.Stopped; // unused\n  public loaded: Promise<void>;\n\n  // fields from IAudio\n  public gain: GainNode;\n  public source: AudioBuffer;\n  public destination: AudioNode;\n  public definition: ISoundSpriteSheet;\n  public context: AudioContext;\n  /**\n   * 1. sets all relevant metadata properties from spritesheet\n   * 2. creates gain node from context\n   * 3. set this.loaded to result of createSource(props.source, props.context);\n   * 4. set this.destination\n   */\n  constructor(props: ISFXProps) {\n    // TODO: 1\n    this.context = props.context;\n    this.definition = props.definition;\n    this.start = this.definition.spritemap[props.texture].start;\n    this.end = this.definition.spritemap[props.texture].end;\n    this.length = this.end - this.start;\n    this.gain = props.context.createGain();\n    this.loaded = this.createSource(props.source, props.context);\n    this.destination = props.context.destination;\n  }\n\n  // calls this.loaded.then(e => this.createPlayInstance());\n  public play(): this {\n    this.loaded.then(e => this.createPlayInstance());\n    return this;\n  }\n\n  // no ops\n  public stop(): this {\n    return this;\n  }\n  public pause(): this {\n    return this;\n  }\n\n  // sets the gainNode.gain.value property\n  // accepts [0..1]\n  public setVolume(volume: number): this {\n    if (volume < 0 || volume > 1) {\n      throw new Error(`setVolume() accepts a number between 0 and 1; got ${volume}.`);\n    }\n    this.gain.gain.value = volume;\n    return this;\n  }\n\n  /**\n   * 1. resolves response to arrayBuffer\n   * 2. creates audioBuffer\n   * 3. creates AudioBufferSourceNode\n   * 4. sets source property\n   */\n  private async createSource(res: Promise<Response>, context: AudioContext): Promise<void> {\n    const resp: Response = await res;\n    const buffer = await resp.arrayBuffer();\n    this.source = await context.decodeAudioData(buffer);\n  }\n\n  /**\n   * 1. creates new AudioBufferSourceNode\n   * 2. set node.buffer = this.source\n   * 3. set source metadata\n   * 4. connect node to destination\n   * 5. call start(0, offset, duration)\n   * 6. listen to ended event (look up the event)\n   * 7. clean up audio source node and disconnect it from the destination\n   */\n  private createPlayInstance(): void {\n    const node = this.context.createBufferSource();\n    node.buffer = this.source;\n    node.loop = this.loop; // false\n    // TODO: 3\n    node.connect(this.gain);\n\n    const now = Date.now();\n    node.start(0, this.start, this.length);\n\n    const gain = this.gain; // must be accessed inside of named function\n    node.addEventListener(\"ended\", function callback(e) {\n      node.disconnect(gain);\n      node.removeEventListener(\"ended\", callback);\n    });\n  }\n}\n","import assert from \"assert\";\nimport { createTextureMap, IInteractionPoint, ITextureMap, loadImage } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface ISlider extends ISprite {\n  value: number;\n  max: number;\n  min: number;\n  width: number;\n}\n\nexport interface ISliderProps extends ISpriteProps {\n  value?: number;\n  max?: number;\n  min?: number;\n  width: number;\n}\n\nexport class Slider extends Sprite implements ISlider {\n  public value: number = 0;\n  public max: number = 1;\n  public min: number = 0;\n  public width: number = 100;\n\n  private sliderPattern: CanvasPattern = null;\n  private pillTexture: ImageBitmap = null;\n\n  constructor(props: ISliderProps) {\n    super(props);\n\n    this.height = props.textures.Pill_Hover.height;\n    this.width = props.width;\n    this.max = props.max || this.max;\n    this.min = props.min || this.min;\n    this.value = props.value || this.value;\n\n    this.sliderPattern = document\n      .createElement(\"canvas\")\n      .getContext(\"2d\")\n      // @ts-ignore: Dom Spec Outdated. ImageBitmap is acceptable parameter for createPattern.\n      .createPattern(props.textures.Line, \"repeat-x\");\n  }\n\n  public broadPhase(point: IInteractionPoint): boolean {\n    if (this.active) {\n      return true;\n    }\n    return super.broadPhase(point);\n  }\n\n  public narrowPhase(point: IInteractionPoint): ISprite {\n    if (this.active) {\n      return this;\n    }\n    const sliderDistance = this.width - this.textures.Pill_Hover.width;\n    const sliderValuePercent = (this.value - this.min) / (this.max - this.min);\n    const valueX = sliderDistance * sliderValuePercent;\n\n    if (point.ty <= this.textures.Pill_Hover.height\n        && point.ty >= 0\n        && point.tx >= valueX\n        && point.tx <= valueX + this.textures.Pill_Hover.width) {\n        return this;\n      }\n  }\n\n  public pointCollision(point: IInteractionPoint): boolean {\n    super.pointCollision(point);\n\n    if (this.active && point.active === this) {\n      const previousValue = this.value;\n      const sliderDistance = this.width - this.textures.Pill_Hover.width;\n      const trueTX = point.tx - this.textures.Pill_Hover.width * 0.5;\n      const clampedTX = Math.max(0, Math.min(trueTX, sliderDistance));\n      const range = this.max - this.min;\n\n      this.value = this.min + range * clampedTX / sliderDistance;\n      if (this.value !== previousValue) {\n        super.emit(\"value-change\", this);\n      }\n    }\n\n    return true;\n  }\n\n  public update(): void {\n    this.cursor = this.hover ? \"pointer\" : \"default\";\n    this.pillTexture = this.active\n      ? this.textures.Pill_Active\n      : (this.hover ? this.textures.Pill_Hover : this.textures.Pill);\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    ctx.drawImage(this.textures.Line_Cap_Left, 0, 0);\n    ctx.drawImage(\n      this.textures.Line_Cap_Right,\n      this.width - this.textures.Line_Cap_Right.width,\n      0,\n    );\n    ctx.fillStyle = this.sliderPattern;\n    ctx.fillRect(\n      this.textures.Line_Cap_Left.width,\n      0,\n      this.width - this.textures.Line_Cap_Left.width - this.textures.Line_Cap_Right.width,\n      this.textures.Line.height,\n    );\n    const sliderDistance = this.width - this.textures.Pill_Hover.width;\n    const sliderValuePercent = (this.value - this.min) / (this.max - this.min);\n    const valueX = sliderDistance * sliderValuePercent;\n\n    ctx.drawImage(this.pillTexture, valueX, 0);\n  }\n}\n\nexport interface ILoadSliderProps extends ISliderProps {\n\n}\n","import { IContainer } from \"./Container\";\nimport { IInteractionManagerProps, InteractionManager } from \"./InteractionManager\";\nimport { ISprite } from \"./Sprite\";\n\nexport interface IStageProps extends IInteractionManagerProps {\n\n}\n\nexport interface IStage extends IContainer {\n  update(): this;\n  render(): this;\n  skipAnimations(): boolean;\n}\n\nexport class Stage extends InteractionManager implements IStage {\n  constructor(props: IStageProps) {\n    super(props);\n  }\n  public update(): this {\n    const now = Date.now();\n    let sprite: ISprite;\n\n    super.emit(\"pre-interpolate\");\n    for (sprite of this.sprites) {\n      sprite.interpolate(now);\n    }\n    super.emit(\"post-interpolate\");\n\n    super.emit(\"pre-hover-check\");\n    this.hoverCheck(now);\n    super.emit(\"post-hover-check\");\n\n    super.emit(\"pre-update\");\n    for (sprite of this.sprites) {\n      sprite.update();\n    }\n    super.emit(\"post-update\");\n\n    return this;\n  }\n\n  public render(): this {\n    super.emit(\"pre-render\");\n    let sprite: ISprite;\n    let pointer: boolean = false;\n    const ctx = this.ctx;\n\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    for (sprite of this.sprites) {\n      ctx.save();\n      ctx.setTransform(\n        sprite.interpolatedPosition[0],\n        sprite.interpolatedPosition[1],\n        sprite.interpolatedPosition[2],\n        sprite.interpolatedPosition[3],\n        sprite.interpolatedPosition[4],\n        sprite.interpolatedPosition[5],\n      );\n      ctx.globalAlpha = sprite.interpolatedPosition[6];\n      sprite.render(ctx);\n      ctx.restore();\n      pointer = pointer || (sprite.hover && sprite.cursor === \"pointer\");\n    }\n\n    this.canvas.style.cursor = pointer ? \"pointer\" : \"default\";\n\n    super.emit(\"post-render\");\n    return this;\n  }\n\n  public skipAnimations(): boolean {\n    const now = Date.now();\n    let result = false;\n    for (const sprite of this.sprites) {\n      if (sprite.skipAnimation(now)) {\n        result = true;\n      }\n    }\n    return result;\n  }\n}\n","import assert from \"assert\";\nimport { createTextureMap, IPadding, ITextureMap, loadImage, TextAlign, TextBaseline } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nconst tempctx = document.createElement(\"canvas\").getContext(\"2d\");\n\nexport interface ITextbox extends ISprite {\n  text: string;\n  textSpeed: number;\n  textIndex: number;\n  padding: IPadding;\n  fontSize: number;\n  font: string;\n  fontColor: string;\n  lineHeight: number;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n\n  setText(text: string): this;\n  appendText(text: string): this;\n}\n\nexport interface ITextboxProps extends ISpriteProps {\n  text?: string;\n  textSpeed?: number;\n  textIndex?: number;\n  textAlign?: TextAlign;\n  textBaseline?: TextBaseline;\n  padding?: IPadding;\n  fontSize?: number;\n  font?: string;\n  fontColor?: string;\n  lineHeight?: number;\n}\n\nexport class Textbox extends Sprite implements ITextbox {\n  private static regex: RegExp = /\\r\\n|\\r|\\n|[^\\t ]*[\\t ]?/g;\n\n  public text: string = \"\";\n  public textSpeed: number = 1;\n  public textIndex: number = 0;\n  public padding: IPadding = {\n    bottom: 5,\n    left: 5,\n    right: 5,\n    top: 5,\n  };\n  public fontSize: number = 12;\n  public font: string = \"monospace\";\n  public fontColor: string = \"black\";\n  public lineHeight: number = 16;\n  public textAlign: TextAlign = TextAlign.left;\n  public textBaseline: TextBaseline = TextBaseline.hanging;\n  private interpolatedText: string[] = [\"\"];\n\n  constructor(props: ITextboxProps) {\n    super(props);\n    this.text = props.text || this.text;\n    this.textSpeed = props.textSpeed || this.textSpeed;\n    if (props.hasOwnProperty(\"textIndex\")) {\n      this.textIndex = props.textIndex;\n    }\n    this.padding = props.padding || this.padding;\n    this.fontSize = props.fontSize || this.fontSize;\n    this.font = props.font || this.font;\n    this.fontColor = props.fontColor || this.fontColor;\n    this.lineHeight = props.lineHeight || this.lineHeight;\n\n    this.setTexture(\"Texture\");\n  }\n\n  public update() {\n    const maxWidth = this.texture.width - this.padding.left - this.padding.right;\n    this.textIndex = Math.min(this.text.length, this.textIndex + this.textSpeed);\n    const words = this.text.match(Textbox.regex);\n    this.interpolatedText = [\"\"];\n    const maxLines = (this.texture.height - this.padding.top - this.padding.bottom) / this.lineHeight;\n    let line: string = \"\";\n    let lineIndex: number = 0;\n    let measurement: TextMetrics;\n    let leftOver: number = this.textIndex;\n    tempctx.font = `${this.fontSize}px ${this.font}`;\n\n    for (const word of words) {\n\n      // If the next character is a newline, push a new line\n      if (word === \"\\n\" || word === \"\\r\\n\" || word === \"\\r\") {\n        this.interpolatedText.push(\"\");\n        leftOver -= word.length;\n        lineIndex += 1;\n        continue;\n      }\n\n      line = this.interpolatedText[lineIndex];\n\n      // If there are no more characters to push, break\n      if (leftOver === 0) {\n        break;\n      }\n\n      // If the line count is greater than the maximum number of lines, break\n      if ((lineIndex + 1) > maxLines) {\n        break;\n      }\n\n      // Test the word length\n      line += word;\n      measurement = tempctx.measureText(line);\n\n      // If the line overflows\n      if (measurement.width > maxWidth) {\n        lineIndex = this.interpolatedText.push(\"\") - 1;\n      }\n\n      this.interpolatedText[lineIndex] += word;\n      // Add the text to the screen\n\n      leftOver -= word.length;\n\n      if (leftOver < 0) {\n        this.interpolatedText[lineIndex] = this.interpolatedText[lineIndex].slice(0, leftOver);\n        break;\n      }\n      // Check to see if the word overFlows the animation\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D) {\n    super.render(ctx);\n    const maxHeight = this.texture.height - this.padding.top;\n    let currentHeight = this.padding.top;\n\n    ctx.font = `${this.fontSize}px ${this.font}`;\n    ctx.fillStyle = this.fontColor;\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n\n    ctx.beginPath();\n    ctx.rect(\n      this.padding.left,\n      this.padding.bottom,\n      this.width - this.padding.right,\n      this.height - this.padding.top,\n    );\n    ctx.clip();\n    for (const line of this.interpolatedText) {\n      if (currentHeight + this.fontSize > maxHeight) {\n        break;\n      }\n\n      ctx.fillText(line, this.padding.left, currentHeight);\n      currentHeight += this.lineHeight;\n    }\n  }\n\n  public setText(text: string): this {\n    if (text.startsWith(this.text)) {\n      this.text = text;\n      return this;\n    }\n\n    this.text = text;\n    this.interpolatedText = [\"\"];\n    this.textIndex = 0;\n    return this;\n  }\n\n  public appendText(text: string): this {\n    this.text += text;\n    return this;\n  }\n\n  public skipAnimation(now: number): boolean {\n    const result: boolean = super.skipAnimation(now) && this.textIndex < this.text.length;\n    this.textIndex = this.text.length;\n    return result;\n  }\n}\n\nexport interface ILoadTextboxProps extends ITextboxProps {\n\n}\n"],"names":["value","immutable","this","Float64Array","Identity","Matrix","x","y","m","translate","scale","angle","rotate","skewX","skewY","props","transform","chain","reset","target","set","inverse","matrix","setMatrix","a","b","c","d","e","f","det","IdentityMatrix","cos","Math","sin","tan","pa","pb","pc","pd","pe","pf","ma","mb","mc","md","me","mf","point","tx","ty","source","i","length","points","points_1","tslib_1.__values","transformPoint","PI","TAU","inFunc","ratio","outFunc","TextAlign","TextBaseline","PlayState","easeLinear","easeInQuad","easeOutQuad","easeInOutQuad","inOut","easeInCub","easeOutCub","easeInOutCub","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeOutSin","easeInSin","easeInOutSin","easeOutElastic","pow","p","easeInElastic","easeInOutElastic","definition","img","textures","Promise","all","Object","entries","frames","map","_a","_b","desc","frame","_c","_d","_e","createImageBitmap","_f","w","h","left","right","z","src","fetch","blob","_super","_this","eases.easeLinear","Image","id","position","m.Identity","m.set","previousPosition","interpolatedPosition","hasOwnProperty","previousAlpha","alpha","interpolatedAlpha","loaded","loadTexture","resolve","tslib_1.__extends","Sprite","width","height","now","interpolate","m.transformPoint","broadPhase","narrowPhase","timespan","wait","ease","animationLength","animationStart","Date","key","Error","result","lastInterpolated","progress","j","m.inverse","parent","m.chain","texture","oldTexture","emit","ctx","drawImage","res","createTextureMap","EventEmitter","center","middle","selected","font","fontColor","fontSize","text","textAlign","textBaseline","Button","setTexture","active","hover","cursor","update","render","fillStyle","fillText","name","displayName","color","checked","Boolean","Checkbox","clicked","toggle","pointCollision","Close","audioContext","AudioContext","Container","sprite","sprites","includes","push","splice","indexOf","playables","captured","down","firstDown","type","event","listener","mouseDown","document","body","mouseUp","mouseMove","touchStart","touchEnd","touchMove","touchCancel","canvas","createElement","appendChild","getContext","hookEvents","addPoint","mousePoint","InteractionManager","events","forEach","addEventListener","removeEventListener","pointDown","pointUp","pointMove","touch","changedTouches","addTouchPoint","touchPointIndex","identifier","removeTouchPoint","pointCancel","hoveringSprite","rect","getBoundingClientRect","clientX","clientY","top","sort","zSort","isHovering","toString","removePoint","tempctx","start","hanging","Label","measureText","sortZ","Panel","collision","beginPath","clip","save","globalAlpha","restore","skipAnimation","Stopped","context","spritemap","end","gain","createGain","createSource","destination","SFXSprite","then","createPlayInstance","volume","arrayBuffer","buffer","decodeAudioData","node","createBufferSource","loop","connect","disconnect","callback","Pill_Hover","max","min","sliderPattern","createPattern","Line","Slider","valueX","previousValue","sliderDistance","clampedTX","pillTexture","Pill_Active","Pill","Line_Cap_Left","Line_Cap_Right","fillRect","Stage","hoverCheck","pointer","clearRect","setTransform","style","bottom","textSpeed","textIndex","padding","lineHeight","Textbox","maxWidth","words","match","regex","interpolatedText","maxLines","line","lineIndex","leftOver","words_1","word","slice","maxHeight","currentHeight","startsWith"],"mappings":"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"}
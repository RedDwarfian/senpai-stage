{"version":3,"file":"senpai-stage.js","sources":["../src/ease/consts.ts","../src/ease/index.ts","../src/matrix/index.ts","../src/util/index.ts","../src/view/Sprite.ts","../src/view/Button.ts","../src/view/Character.ts","../src/view/Checkbox.ts","../src/view/Close.ts","../src/view/Container.ts","../src/view/InteractionManager.ts","../src/view/Label.ts","../src/view/Panel.ts","../src/view/SFXSprite.ts","../src/view/Slider.ts","../src/view/Stage.ts","../src/view/Textbox.ts"],"sourcesContent":["export const PI = Math.PI;\nexport const TAU = 2 * PI;\n","/****\n * Custom ease functions, designed with functional programming concepts.\n */\nimport { PI, TAU } from \"./consts\";\n\nfunction inverse(inFunc: (ratio: number) => number): (ratio: number) => number {\n  return function outFunc(ratio: number): number {\n    return 1 - inFunc(1 - ratio);\n  };\n}\n\nfunction inOut(inFunc: (ratio: number) => number): (ratio: number) => number {\n  const outFunc = inverse(inFunc);\n  return (ratio: number): number => ratio < 0.5\n    ? 0.5 * inFunc(ratio * 2)\n    : 0.5 + 0.5 * outFunc(2 * ratio - 1);\n}\n\nexport const easeLinear: (ratio: number) => number = function linear(ratio: number): number {\n  return ratio;\n};\n\nexport const easeInQuad: (ratio: number) => number = (ratio: number): number => ratio * ratio;\nexport const easeOutQuad: (ratio: number) => number = inverse(easeInQuad);\nexport const easeInOutQuad: (ratio: number) => number = inOut(easeInQuad);\n\nexport const easeInCub: (ratio: number) => number =\n  (ratio: number): number => ratio * ratio * ratio;\nexport const easeOutCub: (ratio: number) => number = inverse(easeInCub);\nexport const easeInOutCub: (ratio: number) => number = inOut(easeInCub);\n\nexport const easeInQuart: (ratio: number) => number =\n  (ratio: number): number => ratio * ratio * ratio * ratio;\nexport const easeOutQuart: (ratio: number) => number = inverse(easeInQuart);\nexport const easeInOutQuart: (ratio: number) => number = inOut(easeInQuart);\n\nexport const easeInQuint: (ratio: number) => number =\n  (ratio: number): number => ratio * ratio * ratio * ratio * ratio;\nexport const easeOutQuint: (ratio: number) => number = inverse(easeInQuint);\nexport const easeInOutQuint: (ratio: number) => number = inOut(easeInQuint);\n\nexport const easeOutSin: (ratio: number) => number =\n  (ratio: number): number => Math.sin(ratio * PI * 0.5);\nexport const easeInSin: (ratio: number) => number = inverse(easeOutSin);\nexport const easeInOutSin: (ratio: number) => number = inOut(easeInSin);\n\nconst p = 0.3;\nexport const easeOutElastic: (ratio: number) => number =\n  (ratio: number): number => Math.pow(2, -10 * ratio) * Math.sin((ratio - p / 4) * TAU / p) + 1;\nexport const easeInElastic: (ratio: number) => number = inverse(easeOutElastic);\nexport const easeInOutElastic: (ratio: number) => number = inOut(easeInElastic);\n","import { IInteractionPoint } from \"../util\";\n\nexport interface IMatrix {\n  value: number[] | Float64Array;\n  immutable: boolean;\n  translate(x: number, y: number): IMatrix;\n  scale(x: number, y: number): IMatrix;\n  rotate(angle: number): IMatrix;\n  skewX(angle: number): IMatrix;\n  skewY(angle: number): IMatrix;\n  transform(props: Float64Array | number[]): IMatrix;\n  inverse(): IMatrix;\n  reset(): IMatrix;\n  set(target: Float64Array | number[]): IMatrix;\n}\n\nexport class Matrix implements IMatrix {\n  public value: number[] | Float64Array = new Float64Array(Identity);\n  public immutable: boolean = false;\n\n  constructor(value?: number[] | Float64Array, immutable?: boolean) {\n    this.value = value || new Float64Array(Identity);\n    this.immutable = immutable || this.immutable;\n  }\n\n  public translate(x: number, y: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      translate(x, y, this.value, m.value);\n      return m;\n    }\n\n    translate(x, y, this.value, this.value);\n    return this;\n  }\n\n  public scale(x: number, y: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      scale(x, y, this.value, m.value);\n      return m;\n    }\n\n    scale(x, y, this.value, this.value);\n    return this;\n  }\n\n  public rotate(angle: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      rotate(angle, this.value, m.value);\n      return m;\n    }\n\n    rotate(angle, this.value, this.value);\n    return this;\n  }\n\n  public skewX(angle: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      skewX(angle, this.value, m.value);\n      return m;\n    }\n\n    skewX(angle, this.value, this.value);\n    return this;\n  }\n\n  public skewY(angle: number): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      skewY(angle, this.value, m.value);\n      return m;\n    }\n\n    skewY(angle, this.value, this.value);\n    return this;\n  }\n\n  public transform(props: Float64Array | number[]): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      transform(this.value, props, m.value);\n      return m;\n    }\n    transform(this.value, props, this.value);\n    return this;\n  }\n\n  public reset(): IMatrix {\n    if (this.immutable) {\n      return chain();\n    }\n    reset(this.value);\n    return this;\n  }\n\n  public set(target: Float64Array | number[]): IMatrix {\n    set(target, this.value);\n    return this;\n  }\n\n  public inverse(): IMatrix {\n    if (this.immutable) {\n      const m = new Matrix(this.value, true);\n      inverse(this.value, m.value);\n      return m;\n    }\n\n    inverse(this.value, this.value);\n    return this;\n  }\n}\n\nexport function inverse(\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  const a: number = matrix[0];\n  const b: number = matrix[1];\n  const c: number = matrix[2];\n  const d: number = matrix[3];\n  const e: number = matrix[4];\n  const f: number = matrix[5];\n  const det: number = 1 / (a * d - c * b);\n\n  setMatrix[0] = d * det;\n  setMatrix[1] = -b * det;\n  setMatrix[2] = -c * det;\n  setMatrix[3] = a * det;\n  setMatrix[4] = (c * f - e * d) * det;\n  setMatrix[5] = (e * b - a * f) * det;\n}\n\nexport const Identity = new Float64Array([1, 0, 0, 1, 0, 0]);\nexport const IdentityMatrix = new Matrix(Identity, true);\n\nexport function translate(\n  x: number,\n  y: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  setMatrix[0] = matrix[0];\n  setMatrix[1] = matrix[1];\n  setMatrix[2] = matrix[2];\n  setMatrix[3] = matrix[3];\n  setMatrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];\n  setMatrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];\n}\n\nexport function scale(\n  x: number,\n  y: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  setMatrix[0] = matrix[0] * x;\n  setMatrix[1] = matrix[1] * x;\n  setMatrix[2] = matrix[2] * y;\n  setMatrix[3] = matrix[3] * y;\n  setMatrix[4] = matrix[4];\n  setMatrix[5] = matrix[5];\n}\n\nexport function rotate(\n  angle: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const a = matrix[0];\n  const b = matrix[1];\n  const c = matrix[2];\n  const d = matrix[3];\n\n  setMatrix[0] = a * cos + c * sin;\n  setMatrix[1] = b * cos + d * sin;\n  setMatrix[2] = c * cos - a * sin;\n  setMatrix[3] = d * cos - b * sin;\n  setMatrix[4] = matrix[4];\n  setMatrix[5] = matrix[5];\n}\n\nexport function skewX(\n  angle: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  const tan = Math.tan(angle);\n\n  setMatrix[0] = matrix[0];\n  setMatrix[1] = matrix[1];\n  setMatrix[2] = matrix[2] + matrix[0] * tan;\n  setMatrix[3] = matrix[3] + matrix[1] * tan;\n  setMatrix[4] = matrix[4];\n  setMatrix[5] = matrix[5];\n}\n\nexport function skewY(\n  angle: number,\n  matrix: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  const tan = Math.tan(angle);\n\n  setMatrix[0] = matrix[0] + matrix[2] * tan;\n  setMatrix[1] = matrix[1] + matrix[3] * tan;\n  setMatrix[2] = matrix[2];\n  setMatrix[3] = matrix[3];\n  setMatrix[4] = matrix[4];\n  setMatrix[5] = matrix[5];\n}\n\nexport function transform(\n  matrix: Float64Array | number[],\n  props: Float64Array | number[],\n  setMatrix: Float64Array | number[],\n): void {\n  // props values\n  const pa = props[0];\n  const pb = props[1];\n  const pc = props[2];\n  const pd = props[3];\n  const pe = props[4];\n  const pf = props[5];\n\n  // matrix values\n  const ma = matrix[0];\n  const mb = matrix[1];\n  const mc = matrix[2];\n  const md = matrix[3];\n  const me = matrix[4];\n  const mf = matrix[5];\n\n  setMatrix[0] = ma * pa + mc * pb;\n  setMatrix[1] = mb * pa + md * pb;\n  setMatrix[2] = ma * pc + mc * pd;\n  setMatrix[3] = mb * pc + md * pd;\n  setMatrix[4] = ma * pe + mc * pf + me;\n  setMatrix[5] = mb * pe + md * pf + mf;\n}\n\nexport function transformPoints(\n  points: IInteractionPoint[],\n  matrix: Float64Array | number[],\n): void {\n  for (const point of points) {\n    transformPoint(point, matrix);\n  }\n}\n\nexport function transformPoint(point: IInteractionPoint, matrix: Float64Array | number[]): void {\n  point.tx = matrix[0] * point.x + matrix[2] * point.y + matrix[4];\n  point.ty = matrix[1] * point.x + matrix[3] * point.y + matrix[5];\n}\n\nexport function set(target: Float64Array | number[], source: Float64Array | number[]): void {\n  for (let i = 0; i < target.length && i < source.length; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function reset(target: Float64Array | number[]): void {\n  return set(target, [1, 0, 0, 1, 0, 0]);\n}\n\nexport function chain(\n  value: Float64Array | number[] = Identity,\n  immutable: boolean = false,\n): IMatrix {\n  return new Matrix(value, immutable);\n}\n","import { ISprite } from \"../view/Sprite\";\n\nexport interface IPoint {\n  x: number;\n  y: number;\n}\n\nexport interface ISpriteSheet {\n  frames: ISpriteSheetFrameMap;\n  meta: ISpriteSheetMeta;\n}\n\nexport interface ISpriteSheetFrameMap {\n  [frame: string]: ISpriteSheetFrame;\n}\n\nexport interface ISpriteSheetMeta {\n  app: string;\n  version: string;\n  image: string;\n  size: ISpriteSheetSize;\n  scale: number;\n}\n\nexport interface ISpriteSheetFrame {\n  frame: ISpriteSheetPoint & ISpriteSheetSize;\n  rotated: boolean;\n  trimmed: boolean;\n  spriteSourceSize: ISpriteSheetPoint & ISpriteSheetSize;\n  sourceSize: ISpriteSheetSize;\n}\n\nexport interface ISpriteSheetSize {\n  w: number;\n  h: number;\n}\n\nexport interface ISpriteSheetPoint {\n  x: number;\n  y: number;\n}\n\nexport interface ITextureMap {\n  [texture: string]: ImageBitmap;\n}\n\nexport interface IInteractionPoint extends IPoint {\n  id: string;\n  type: \"Touch\" | \"Mouse\";\n  down: boolean;\n  clicked: boolean;\n  captured: boolean;\n  active: ISprite;\n  hover: ISprite;\n  firstDown: boolean;\n  tx: number;\n  ty: number;\n}\n\nexport interface IPlayable {\n  started: number; // timestamp when the media last began playing\n  length: number; // media play length timespan\n  start: number; // media start time\n  end: number; // media end time\n  loop: boolean; // does this media loop?\n  state: PlayState; // self explainatory\n  loaded: Promise<void>; // this should be a promise that resolves once the audio has loaded\n  play(): this;\n  pause(): this;\n  stop(): this;\n  setVolume(volume: number); // accepts number [0. 1]\n}\n\nexport interface IAudio extends IPlayable {\n  gain: GainNode; // controls volume\n  source: AudioBuffer; // is null until the audioBuffer is loaded\n  destination: AudioNode;\n  definition: ISoundSpriteSheet; // this will be the provided sound sprite sheet\n  context: AudioContext; // provided audio context for creating the sound sprite\n}\n\nexport interface ISoundSpriteSheet {\n  resources: string[];\n  spritemap: {\n    [name: string]: ISoundSpriteSheetTexture;\n  };\n}\n\nexport interface ISoundSpriteSheetTexture {\n  start: number;\n  end: number;\n  loop: boolean;\n}\n\nexport interface IAudioProps extends IPlayableProps {\n  definition: ISoundSpriteSheet; // this will be the provided sound sprite sheet\n  context: AudioContext; // provided audio context for creating the sound sprite\n  name: string; // determines the name of the audio clip\n}\n\nexport interface IPlayableProps {\n  source: Promise<Response>;\n  texture: string; // this should be name of the texture in the spritesheet\n}\n\nexport interface IKeyState {\n  key: string;\n  down: boolean;\n}\n\nexport interface ISize {\n  width: number;\n  height: number;\n}\n\nexport interface IPadding {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n}\n\nexport async function createTextureMap(definition: ISpriteSheet, img: Promise<ImageBitmap>) {\n  const textures: ITextureMap = {};\n  await Promise.all(\n    Object.entries(definition.frames).map(async ([desc, frame], i) => {\n      textures[desc] = await createImageBitmap(\n        await img,\n        frame.frame.x,\n        frame.frame.y,\n        frame.frame.w,\n        frame.frame.h,\n      );\n    }),\n  );\n  return textures;\n}\n\nexport async function loadImage(src: string): Promise<ImageBitmap> {\n  const res = await fetch(src);\n  const blob = await res.blob();\n  const bmp = await createImageBitmap(blob);\n  return bmp;\n}\n\nexport function zSort(left: ISprite, right: ISprite): number {\n  return left.z - right.z;\n}\n\nexport enum TextAlign {\n  \"left\" = \"left\",\n  \"right\" = \"right\",\n  \"center\" = \"center\",\n  \"start\" = \"start\",\n  \"end\" = \"end\",\n}\n\nexport enum TextBaseline {\n  \"top\" = \"top\",\n  \"hanging\" = \"hanging\",\n  \"middle\" = \"middle\",\n  \"alphabetic\" = \"alphabetic\",\n  \"ideographic\" = \"ideographic\",\n  \"bottom\" = \"bottom\",\n}\n\nexport enum PlayState {\n  Playing,\n    Paused,\n    Stopped,\n}\n","import assert from \"assert\";\nimport { EventEmitter } from \"events\";\nimport * as eases from \"../ease\";\nimport * as m from \"../matrix\";\nimport { createTextureMap, IInteractionPoint, IKeyState, ISize, ISpriteSheet, ITextureMap, loadImage } from \"../util\";\nimport { IStage } from \"./Stage\";\n\nexport interface ISprite extends ISize {\n  id: string;\n  parent: IStage | ISprite;\n\n  // position\n\n  previousPosition: Float64Array;\n  position: Float64Array;\n  inverse: Float64Array;\n  alpha: number;\n  interpolatedAlpha: number;\n  previousAlpha: number;\n  z: number;\n\n  // animation\n\n  lastInterpolated: number;\n  interpolatedPosition: Float64Array;\n  animationStart: number;\n  animationLength: number;\n  wait: number;\n  // stage properties\n\n  active: boolean;\n  hover: boolean;\n  down: boolean;\n  cursor: \"pointer\" | \"default\";\n  loaded: Promise<void>;\n\n  texture: ImageBitmap | HTMLCanvasElement | HTMLImageElement;\n\n  // this is set by the over function\n  ease(ratio: number): number;\n\n  broadPhase(point: IInteractionPoint): boolean;\n  narrowPhase(point: IInteractionPoint): ISprite;\n  isHovering(point: IInteractionPoint, now: number): ISprite;\n  pointCollision(point: IInteractionPoint): boolean;\n  keyStateChange(key: IKeyState): void;\n  setTexture(texture: string): this;\n  over(timespan: number, wait: number, ease: (ratio: number) => number): this;\n  move(position: number[] | Float64Array): this;\n  setZ(z: number): this;\n  setAlpha(alpha: number): this;\n  interpolate(now: number): void;\n  skipAnimation(now: number): boolean;\n  update(): void;\n  render(ctx: CanvasRenderingContext2D): void;\n  emit(event: string, ...args: any[]): boolean;\n\n  on(event: \"point-move\", callback: (sprite: ISprite, point: IInteractionPoint) => void);\n  on(event: string, callback: () => void): this;\n\n  on(event: \"point-move\", callback: (sprite: ISprite, point: IInteractionPoint) => void);\n  once(event: string, callback: () => void): this;\n\n  removeAllListeners(event: string | symbol): this;\n  eventNames(): Array<string | symbol>;\n}\n\nexport interface ISpriteProps {\n  id: string;\n  position: Float64Array | number[];\n  textures?: ITextureMap;\n  alpha?: number;\n  z?: number;\n  source: Promise<Response>;\n  definition: ISpriteSheet;\n}\n\nexport class Sprite extends EventEmitter implements ISprite {\n  public id: string = \"\";\n  public position: Float64Array = new Float64Array(6);\n  public previousPosition: Float64Array = new Float64Array(6);\n  public interpolatedPosition: Float64Array = new Float64Array(6);\n  public inverse: Float64Array = new Float64Array(6);\n  public alpha: number = 1;\n  public interpolatedAlpha: number = 1;\n  public previousAlpha: number = 1;\n  public z: number = 0;\n  public parent: ISprite = null;\n  public wait: number = 0;\n\n  public lastInterpolated: number = 0;\n  public animationStart: number = 0;\n  public ease = eases.easeLinear;\n  public cursor: (\"pointer\" | \"default\") = \"default\";\n  public animationLength: number = 0;\n  public active: boolean = false;\n  public hover: boolean = false;\n  public down: boolean = false;\n  public textures: ITextureMap = {};\n  public texture: ImageBitmap | HTMLCanvasElement | HTMLImageElement = new Image();\n  public loaded: Promise<void> = null;\n\n  public width: number = 0;\n  public height: number = 0;\n\n  constructor(props: ISpriteProps) {\n    super();\n    this.id = props.id;\n    const position = props.position || m.Identity;\n    this.textures = props.textures ? props.textures : this.textures;\n    m.set(this.position, position);\n    m.set(this.previousPosition, position);\n    m.set(this.interpolatedPosition, position);\n\n    if (props.hasOwnProperty(\"alpha\")) {\n      this.previousAlpha = this.alpha = this.interpolatedAlpha = props.alpha;\n    }\n    if (props.hasOwnProperty(\"z\")) {\n      this.z = props.z;\n    }\n    this.loaded = props.source ? this.loadTexture(props.source, props.definition) : Promise.resolve();\n  }\n\n  public broadPhase(point: IInteractionPoint): boolean {\n    return point.tx >= 0 && point.tx <= this.width && point.ty >= 0 && point.ty <= this.height;\n  }\n\n  public narrowPhase(point: IInteractionPoint): ISprite {\n    return this;\n  }\n\n  public pointCollision(point: IInteractionPoint): boolean {\n    return true;\n  }\n\n  public isHovering(point: IInteractionPoint, now: number): ISprite {\n    this.interpolate(now);\n    m.transformPoint(point, this.inverse);\n    if (this.broadPhase(point)) {\n      return this.narrowPhase(point);\n    }\n  }\n\n  public move(position: number[] | Float64Array): this {\n    this.previousPosition[0] = this.interpolatedPosition[0];\n    this.previousPosition[1] = this.interpolatedPosition[1];\n    this.previousPosition[2] = this.interpolatedPosition[2];\n    this.previousPosition[3] = this.interpolatedPosition[3];\n    this.previousPosition[4] = this.interpolatedPosition[4];\n    this.previousPosition[5] = this.interpolatedPosition[5];\n\n    this.position[0] = position[0];\n    this.position[1] = position[1];\n    this.position[2] = position[2];\n    this.position[3] = position[3];\n    this.position[4] = position[4];\n    this.position[5] = position[5];\n    return this;\n  }\n\n  public setAlpha(alpha: number): this {\n    this.previousAlpha = this.interpolatedAlpha;\n    this.alpha = alpha;\n    return this;\n  }\n\n  public setZ(z: number): this {\n    this.z = z;\n    return this;\n  }\n\n  public over(timespan: number, wait: number = 0, ease: (ratio: number) => number = this.ease): this {\n    this.animationLength = timespan;\n    this.animationStart = Date.now();\n    this.ease = ease || this.ease;\n    this.wait = wait;\n    return this;\n  }\n\n  public keyStateChange(key: IKeyState): void {\n    throw new Error(\"Not implemented.\");\n  }\n\n  public skipAnimation(now: number): boolean {\n    const result: boolean = now < this.animationLength + this.animationStart;\n    this.animationStart = now - this.animationLength;\n    return result;\n  }\n\n  public update(): void {\n    // No op\n  }\n  public interpolate(now: number): void {\n    if (now <= this.lastInterpolated) {\n      return;\n    }\n    this.lastInterpolated = now;\n\n    const progress = now - (this.animationStart + this.wait);\n\n    const ratio = (progress >= this.animationLength)\n        ? 1\n        : (progress <= 0 ? 0 : this.ease(progress / this.animationLength));\n\n    if (ratio === 1) {\n      this.interpolatedPosition[0] = this.position[0];\n      this.interpolatedPosition[1] = this.position[1];\n      this.interpolatedPosition[2] = this.position[2];\n      this.interpolatedPosition[3] = this.position[3];\n      this.interpolatedPosition[4] = this.position[4];\n      this.interpolatedPosition[5] = this.position[5];\n      this.interpolatedAlpha = this.alpha;\n    } else if (ratio === 0) {\n      this.interpolatedPosition[0] = this.previousPosition[0];\n      this.interpolatedPosition[1] = this.previousPosition[1];\n      this.interpolatedPosition[2] = this.previousPosition[2];\n      this.interpolatedPosition[3] = this.previousPosition[3];\n      this.interpolatedPosition[4] = this.previousPosition[4];\n      this.interpolatedPosition[5] = this.previousPosition[5];\n      this.interpolatedAlpha = this.previousAlpha;\n    } else {\n      for (let j = 0; j < 6; j++) {\n        this.interpolatedPosition[j] = this.previousPosition[j]\n          + ratio * (this.position[j] - this.previousPosition[j]);\n      }\n      this.interpolatedAlpha = this.previousAlpha + ratio * (this.alpha - this.previousAlpha);\n    }\n\n    m.inverse(this.interpolatedPosition, this.inverse);\n\n    if (this.parent) {\n      this.parent.interpolate(now);\n\n      m.chain(this.parent.inverse, true)\n        .transform(this.inverse)\n        .set(this.inverse);\n    }\n  }\n  public setTexture(texture: string): this {\n    const oldTexture = this.texture;\n    this.texture = this.textures[texture];\n    this.width = this.texture.width;\n    this.height = this.texture.height;\n\n    if (oldTexture !== this.texture) {\n      this.emit(\"texture-change\", this.texture);\n    }\n\n    return this;\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    ctx.drawImage(this.texture, 0, 0);\n  }\n\n  private async loadTexture(res: Promise<Response>, definition: ISpriteSheet): Promise<void> {\n    const resp = await res;\n    const blob = await resp.blob();\n    this.textures = await createTextureMap(definition, createImageBitmap(blob));\n  }\n}\n\nexport interface ILoadSpriteProps extends ISpriteProps {\n\n}\n","import { createTextureMap,  ITextureMap, loadImage, TextAlign, TextBaseline } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nimport assert from \"assert\";\n\nexport interface IButton extends ISprite {\n  selected: boolean;\n  font: string;\n  fontColor: string;\n  fontSize: number;\n  text: string;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n  setText(text: string): this;\n}\n\nexport interface IButtonProps extends ISpriteProps {\n  selected?: boolean;\n  font?: string;\n  fontColor?: string;\n  fontSize?: number;\n  text?: string;\n  textAlign?: TextAlign;\n  textBaseline?: TextBaseline;\n}\n\nexport class Button extends Sprite implements IButton {\n  public selected: boolean = false;\n  public font: string = \"monospace\";\n  public fontColor: string = \"black\";\n  public fontSize: number = 12;\n  public text: string =  \"\";\n  public textAlign: TextAlign = TextAlign.center;\n  public textBaseline: TextBaseline = TextBaseline.middle;\n\n  constructor(props: IButtonProps) {\n    super(props);\n    this.selected = props.selected || false;\n    this.font = props.font || this.font;\n    this.fontColor = props.fontColor || this.fontColor;\n    this.fontSize = props.fontSize || this.fontSize;\n    this.text = props.text || this.text;\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n\n  public update(): void {\n    const active = this.active ? \"Active\" : \"Inactive\";\n    const hover = this.hover ? \"Hover\" : \"NoHover\";\n    const selected = this.selected ? \"Selected\" : \"Unselected\";\n    this.setTexture(`${active}_${hover}_${selected}`);\n\n    this.cursor = this.hover ? \"pointer\" : \"default\";\n    super.update();\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    super.render(ctx);\n    ctx.translate(this.texture.width * 0.5, this.texture.height * 0.5);\n    ctx.textBaseline = TextBaseline.middle;\n    ctx.textAlign = TextAlign.center;\n    ctx.font = `${this.fontSize}px ${this.font}`;\n    ctx.fillStyle = this.fontColor;\n    ctx.fillText(this.text, 0, 0);\n  }\n\n  public setText(text: string): this {\n    this.text = text;\n    return this;\n  }\n}\n\nexport interface ILoadButtonProps extends IButtonProps {\n\n}\n","import assert from \"assert\";\nimport { createTextureMap, loadImage } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface ICharacterProps extends ISpriteProps {\n  name: string;\n  displayName: string;\n  color: string;\n}\n\nexport interface ICharacter extends ISprite {\n  name: string;\n  displayName: string;\n  color: string;\n}\n\nexport class Character extends Sprite implements ICharacter {\n  public name: string = \"\";\n  public displayName: string = \"\";\n  public color: string = \"\";\n  constructor(props: ICharacterProps) {\n    super(props);\n    this.name = props.name;\n    this.displayName = props.displayName;\n    this.color = props.color;\n  }\n}\n\nexport interface ILoadCharacterProps extends ICharacterProps {\n\n}\n","import assert from \"assert\";\nimport {\n  createTextureMap,\n  IInteractionPoint,\n  ITextureMap,\n  loadImage,\n  TextAlign,\n  TextBaseline,\n} from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface ICheckbox extends ISprite {\n  checked: boolean;\n  text: string;\n  font: string;\n  fontColor: string;\n  fontSize: number;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n\n  setText(text: string): this;\n  toggle(): this;\n}\n\nexport interface ICheckboxProps extends ISpriteProps {\n  checked?: boolean;\n  text?: string;\n  font?: string;\n  fontColor?: string;\n  fontSize?: number;\n  textAlign?: TextAlign;\n  textBaseline?: TextBaseline;\n}\n\nexport class Checkbox extends Sprite implements ICheckbox {\n  public checked: boolean = false;\n  public text: string = \"\";\n  public font: string = \"monospace\";\n  public fontColor: string = \"black\";\n  public fontSize: number = 12;\n  public textAlign: TextAlign = TextAlign.left;\n  public textBaseline: TextBaseline = TextBaseline.middle;\n\n  constructor(props: ICheckboxProps) {\n    super(props);\n    this.checked = Boolean(props.checked) || false;\n    this.text = props.text || this.text;\n    this.font = props.font || this.font;\n    this.fontColor = props.fontColor || this.fontColor;\n    this.textAlign = props.textAlign || this.textAlign;\n    this.textBaseline = props.textBaseline || this.textBaseline;\n  }\n\n  public toggle(): this {\n    this.checked = !this.checked;\n    return this;\n  }\n\n  public pointCollision(point: IInteractionPoint): boolean {\n    if (point.clicked && point.active === this) {\n      this.toggle();\n      this.emit(\"toggle\", point);\n    }\n    return super.pointCollision(point);\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    super.render(ctx);\n    ctx.translate(this.width * 1.1, this.height / 2);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    ctx.fillStyle = this.fontColor;\n    ctx.font = `${this.fontSize}px ${this.font}`;\n    ctx.fillText(this.text, 0, 0);\n  }\n\n  public update(): void {\n    const active = this.active ? \"Active\" : \"Inactive\";\n    const hover = this.hover ? \"Hover\" : \"NoHover\";\n    const checked = this.checked ? \"Checked\" : \"Unchecked\";\n    this.setTexture(`${active}_${hover}_${checked}`);\n\n    this.cursor = this.hover ? \"pointer\" : \"default\";\n    super.update();\n  }\n\n  public setText(text: string): this {\n    this.text = text;\n    return this;\n  }\n}\n\nexport interface ILoadCheckboxProps extends ICheckboxProps {\n\n}\n","import assert from \"assert\";\nimport { createTextureMap, ITextureMap, loadImage } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface IClose extends ISprite {\n\n}\n\nexport interface ICloseProps extends ISpriteProps {\n\n}\n\nexport class Close extends Sprite implements IClose {\n  constructor(props: ICloseProps) {\n    super(props);\n  }\n  public update(): void {\n    const active = this.active ? \"Active\" : \"Inactive\";\n    const hover = this.hover ? \"Hover\" : \"NoHover\";\n    this.setTexture(`${active}_${hover}`);\n\n    this.cursor = this.hover ? \"pointer\" : \"default\";\n    super.update();\n  }\n}\n\nexport interface ILoadCloseProps extends ICloseProps {\n\n}\n","import { EventEmitter } from \"events\";\nimport { IInteractionPoint, IPlayable } from \"../util\";\nimport { ISprite } from \"./Sprite\";\n\nexport interface IContainer {\n  sprites: ISprite[];\n  playables: IPlayable[];\n  points: IInteractionPoint[];\n  audioContext: AudioContext;\n\n  addSprite(sprite: ISprite): this;\n  removeSprite(sprite: ISprite): this;\n  addPlayable(sprite: IPlayable): this;\n  removePlayable(sprite: IPlayable): this;\n  addPoint(point: IInteractionPoint): this;\n  removePoint(point: IInteractionPoint): this;\n}\n\nexport interface IContainerProps {\n  audioContext: AudioContext;\n}\n\nexport class Container extends EventEmitter implements IContainer {\n\n  public sprites: ISprite[] = [];\n  public playables: IPlayable[] = [];\n  public points: IInteractionPoint[] = [];\n  public audioContext: AudioContext = null;\n\n  constructor(props: IContainerProps) {\n    super();\n    this.audioContext = props.audioContext || new AudioContext();\n  }\n\n  public addSprite(sprite: ISprite): this {\n    if (!this.sprites.includes(sprite)) {\n      this.sprites.push(sprite);\n    }\n    return this;\n  }\n\n  public removeSprite(sprite: ISprite): this {\n    if (this.sprites.includes(sprite)) {\n      this.sprites.splice(this.sprites.indexOf(sprite), 1);\n    }\n    return this;\n  }\n\n  public addPlayable(sprite: IPlayable): this {\n    if (!this.playables.includes(sprite)) {\n      this.playables.push(sprite);\n      // NOTE: This may be audio specific?\n      //      sprite.gain.connect(this.audioContext.destination);\n    }\n    return this;\n  }\n\n  public removePlayable(sprite: IPlayable): this {\n    if (this.playables.includes(sprite)) {\n      this.playables.splice(this.playables.indexOf(sprite), 1);\n      // NOTE: This may be audio specific?\n      //      sprite.gain.disconnect(this.audioContext.destination);\n    }\n    return this;\n  }\n\n  public addPoint(point: IInteractionPoint): this {\n    if (!this.points.includes(point)) {\n      this.points.push(point);\n    }\n    return this;\n  }\n\n  public removePoint(point: IInteractionPoint): this {\n    if (this.points.includes(point)) {\n      this.points.splice(this.points.indexOf(point), 1);\n    }\n    return this;\n  }\n}\n","import { transformPoint } from \"../matrix\";\nimport { IInteractionPoint, zSort } from \"../util\";\nimport { Container, IContainer, IContainerProps } from \"./Container\";\nimport { ISprite } from \"./Sprite\";\n\ninterface IInteractionPointIndex {\n  [id: number]: IInteractionPoint;\n}\n\nexport interface IInteractionManager extends IContainer {\n  canvas: HTMLCanvasElement;\n  mousePoint: IInteractionPoint;\n  touchPointIndex: IInteractionPointIndex;\n\n  hookEvents(): void;\n  dispose(): void;\n  addTouchPoint(touch: Touch): IInteractionPoint;\n  removeTouchPoint(touch: Touch): void;\n  pointDown(point: IInteractionPoint, position: Touch | MouseEvent): void;\n  pointUp(point: IInteractionPoint, position: Touch | MouseEvent): void;\n  pointMove(point: IInteractionPoint, position: Touch | MouseEvent): void;\n  pointCancel(point: IInteractionPoint, position: Touch | MouseEvent): void;\n\n  // high level events\n  mouseDown(event: MouseEvent): void;\n  mouseUp(event: MouseEvent): void;\n  mouseMove(event: MouseEvent): void;\n  touchStart(event: TouchEvent): void;\n  touchEnd(event: TouchEvent): void;\n  touchMove(event: TouchEvent): void;\n  touchCancel(event: TouchEvent): void;\n}\n\ninterface IInteractionPointEvent {\n  target: HTMLElement;\n  event: string;\n  listener: (e: MouseEvent | TouchEvent) => void;\n}\n\nexport interface IInteractionManagerProps extends IContainerProps {\n  canvas: HTMLCanvasElement;\n  width: number;\n  height: number;\n}\n\nexport class InteractionManager extends Container implements IInteractionManager {\n  public canvas: HTMLCanvasElement = null;\n  public ctx: CanvasRenderingContext2D = null;\n  public touchPointIndex: IInteractionPointIndex = {};\n  public mousePoint: IInteractionPoint = {\n    active: null,\n    captured: false,\n    clicked: false,\n    down: false,\n    firstDown: false,\n    hover: null,\n    id: \"mouse\",\n    tx: 0,\n    ty: 0,\n    type: \"Mouse\",\n    x: 0,\n    y: 0,\n  };\n  private events: IInteractionPointEvent[] = [\n    { target: null, event: \"mousedown\", listener: e => this.mouseDown(e as MouseEvent) },\n    { target: document.body, event: \"mouseup\", listener: e => this.mouseUp(e as MouseEvent) },\n    { target: null, event: \"mousemove\", listener: e => this.mouseMove(e as MouseEvent) },\n    { target: null, event: \"touchstart\", listener: e => this.touchStart(e as TouchEvent) },\n    { target: document.body, event: \"touchend\", listener: e => this.touchEnd(e as TouchEvent) },\n    { target: null, event: \"touchmove\", listener: e => this.touchMove(e as TouchEvent) },\n    { target: document.body, event: \"touchcancel\", listener: e => this.touchCancel(e as TouchEvent) },\n  ];\n\n  constructor(props: IInteractionManagerProps) {\n    super(props);\n    this.canvas = props.canvas;\n    if (!this.canvas) {\n      this.canvas = document.createElement(\"canvas\");\n      document.body.appendChild(this.canvas);\n    }\n    this.canvas.width = props.width;\n    this.canvas.height = props.height;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.hookEvents();\n    this.addPoint(this.mousePoint);\n  }\n\n  public hookEvents(): void {\n    this.events.forEach(\n      event => (event.target || this.canvas)\n        .addEventListener(event.event, event.listener),\n    );\n  }\n\n  public dispose(): void {\n    this.events.forEach(\n      event => (event.target || this.canvas)\n        .removeEventListener(event.event, event.listener),\n    );\n  }\n\n  public mouseDown(event: MouseEvent): void {\n    return this.pointDown(this.mousePoint, event);\n  }\n\n  public mouseUp(event: MouseEvent): void {\n    return this.pointUp(this.mousePoint, event);\n  }\n\n  public mouseMove(event: MouseEvent): void {\n    return this.pointMove(this.mousePoint, event);\n  }\n\n  public touchStart(event: TouchEvent): void {\n    let touch: Touch;\n    let point: IInteractionPoint;\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < event.changedTouches.length; i++) {\n      touch = event.changedTouches[i];\n      point = this.addTouchPoint(touch);\n      this.pointDown(point, touch);\n    }\n  }\n\n  public touchEnd(event: TouchEvent): void {\n    let touch: Touch = null;\n    let point: IInteractionPoint;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < event.changedTouches.length; i++) {\n      touch = event.changedTouches[i];\n      point = this.touchPointIndex[touch.identifier];\n      this.pointUp(point, touch);\n      this.removeTouchPoint(touch);\n    }\n  }\n\n  public touchCancel(event: TouchEvent): void {\n    let touch: Touch = null;\n    let point: IInteractionPoint;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < event.changedTouches.length; i++) {\n      touch = event.changedTouches[i];\n      point = this.touchPointIndex[touch.identifier];\n      this.pointCancel(point, touch);\n      this.removeTouchPoint(touch);\n    }\n  }\n\n  public touchMove(event: TouchEvent): void {\n    let touch: Touch = null;\n    let point: IInteractionPoint;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < event.changedTouches.length; i++) {\n      touch = event.changedTouches[i];\n      point = this.touchPointIndex[touch.identifier];\n      this.pointMove(point, touch);\n    }\n  }\n  public pointDown(point: IInteractionPoint, position: Touch | MouseEvent): void {\n    this.pointMove(point, position);\n    if (point.hover) {\n      point.active = point.hover;\n      point.active.down = true;\n      point.active.active = true;\n      point.active.emit(\"down\", point);\n    }\n    this.emit(\"firstdown\", point);\n  }\n\n  public pointUp(point: IInteractionPoint, position: Touch | MouseEvent): void {\n    this.pointMove(point, position);\n    if (point.active) {\n      point.active.emit(\"up\", point);\n    }\n    if (point.active && point.hover === point.active) {\n      point.active.emit(\"click\", point);\n      point.active.down = false;\n      point.active.active = false;\n      point.active = null;\n    }\n    this.emit(\"click\", point);\n  }\n\n  public pointMove(point: IInteractionPoint, position: Touch | MouseEvent): void {\n    const now = Date.now();\n    const rect = this.canvas.getBoundingClientRect();\n    point.x = position.clientX - rect.left;\n    point.y = position.clientY - rect.top;\n\n    if (point.hover) {\n      point.hover.hover = false;\n      point.hover = null;\n    }\n    this.sprites.sort(zSort);\n\n    let sprite: ISprite;\n    let hoveringSprite: ISprite;\n    for (let i = this.sprites.length - 1; i >= 0; i--) {\n      sprite = this.sprites[i];\n      hoveringSprite = sprite.isHovering(point, now);\n\n      if (hoveringSprite) {\n        hoveringSprite.hover = true;\n        point.hover = hoveringSprite;\n        hoveringSprite.pointCollision(point);\n        hoveringSprite.emit(\"point-move\", point);\n      }\n    }\n\n    super.emit(\"point-move\", point);\n  }\n\n  public pointCancel(point: IInteractionPoint, position: Touch | MouseEvent): void {\n    if (point.active) {\n      point.active.active = false;\n      point.active = null;\n    }\n    if (point.hover) {\n      point.hover.hover = false;\n      point.hover = null;\n    }\n  }\n\n  public addTouchPoint(touch: Touch): IInteractionPoint {\n    const point: IInteractionPoint = {\n      active: null,\n      captured: false,\n      clicked: false,\n      down: false,\n      firstDown: false,\n      hover: null,\n      id: touch.identifier.toString(),\n      tx: 0,\n      ty: 0,\n      type: \"Touch\",\n      x: 0,\n      y: 0,\n    };\n    this.touchPointIndex[touch.identifier] = point;\n    this.points.push(point);\n    return point;\n  }\n\n  public removeTouchPoint(touch: Touch): void {\n    const point: IInteractionPoint = this.touchPointIndex[touch.identifier];\n    delete this.touchPointIndex[touch.identifier];\n    this.removePoint(point);\n  }\n\n  public hoverCheck(now: number): void {\n    let point: IInteractionPoint;\n    let sprite: ISprite;\n\n    for (point of this.points) {\n      if (point.hover) {\n        point.hover.hover = false;\n        point.hover = null;\n      }\n\n      for (sprite of this.sprites) {\n        if (sprite.isHovering(point, now)) {\n          sprite.pointCollision(point);\n          point.hover = sprite;\n          sprite.hover = true;\n          break;\n        }\n      }\n    }\n  }\n}\n","import { TextAlign, TextBaseline } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface ILabel extends ISprite {\n  text: string;\n  font: string;\n  fontSize: number;\n  fontColor: string;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n  setText(text: string): this;\n}\n\nexport interface ILabelProps extends ISpriteProps {\n  text?: string;\n  font?: string;\n  fontSize?: number;\n  fontColor?: string;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n}\n\nconst tempctx = document.createElement(\"canvas\").getContext(\"2d\");\n\nexport class Label extends Sprite implements ILabel {\n  public text: string = \"\";\n  public font: string = \"monospace\";\n  public fontSize: number = 12;\n  public fontColor: string = \"black\";\n  public textAlign: TextAlign = TextAlign.start;\n  public textBaseline: TextBaseline = TextBaseline.hanging;\n\n  constructor(props: ILabelProps) {\n    super(props);\n    this.text = props.text || this.text;\n    this.font = props.font || this.font;\n    this.fontSize = props.fontSize || this.fontSize;\n    this.fontColor = props.fontColor || this.fontColor;\n    this.textBaseline = props.textBaseline || this.textBaseline;\n    this.textAlign = props.textAlign || this.textAlign;\n  }\n\n  public update(): void {\n    this.height = this.fontSize;\n    tempctx.font = `${this.fontSize}px ${this.font}`;\n    this.width = tempctx.measureText(this.text).width;\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    ctx.translate(this.texture.width * 0.5, this.texture.height * 0.5);\n    ctx.textBaseline = this.textBaseline;\n    ctx.textAlign = this.textAlign;\n    ctx.font = `${this.fontSize}px ${this.font}`;\n    ctx.fillStyle = this.fontColor;\n    ctx.fillText(this.text, 0, 0);\n  }\n\n  public setText(text: string): this {\n    this.text = text;\n    return this;\n  }\n}\n","import assert from \"assert\";\nimport { transformPoint } from \"../matrix\";\nimport { createTextureMap, IInteractionPoint, ITextureMap, loadImage } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nconst sortZ = (a: ISprite, b: ISprite): number => a.z - b.z;\n\nexport interface IPanel extends ISprite {\n  addSprite(sprite: ISprite): this;\n  removeSprite(sprite: ISprite): this;\n}\n\nexport interface IPanelProps extends ISpriteProps {\n  sprites?: ISprite[];\n}\n\nexport class Panel extends Sprite implements IPanel {\n  private sprites: ISprite[] = [];\n\n  constructor(props: IPanelProps) {\n    super(props);\n    this.sprites = props.sprites || this.sprites;\n  }\n\n  public addSprite(sprite: ISprite): this {\n    sprite.parent = this;\n    this.sprites.push(sprite);\n    return this;\n  }\n\n  public interpolate(now: number) {\n    if (now <= this.lastInterpolated) {\n      return;\n    }\n    super.interpolate(now);\n    for (const sprite of this.sprites) {\n      sprite.interpolate(now);\n    }\n  }\n\n  public removeSprite(sprite: ISprite): this {\n    if (this.sprites.includes(sprite)) {\n      this.sprites.splice(this.sprites.indexOf(sprite), 1);\n      sprite.parent = null;\n    }\n\n    return this;\n  }\n\n  public broadPhase(point: IInteractionPoint): boolean {\n    this.sprites.sort(sortZ);\n\n    for (const sprite of this.sprites) {\n      sprite.down = false;\n      sprite.hover = false;\n    }\n    return super.broadPhase(point);\n  }\n  public narrowPhase(point: IInteractionPoint): ISprite {\n    let sprite: ISprite = null;\n    let collision: ISprite = null;\n\n    for (let i = this.sprites.length - 1; i >= 0; i--) {\n      sprite = this.sprites[i];\n\n      // the sprites inverse has already been calculated relative to the parent\n      transformPoint(point, sprite.inverse);\n\n      if (!sprite.broadPhase(point)) {\n        continue;\n      }\n\n      collision = sprite.narrowPhase(point);\n      if (collision) {\n        return collision;\n      }\n    }\n    return this;\n  }\n  public update(): void {\n    this.hover = false;\n    for (const sprite of this.sprites) {\n      sprite.update();\n\n      if (sprite.hover) {\n        this.hover = sprite.hover;\n        this.cursor = sprite.cursor;\n      }\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    super.render(ctx);\n\n    ctx.beginPath();\n    ctx.rect(0, 0, this.width, this.height);\n    ctx.clip();\n\n    for (const sprite of this.sprites) {\n      ctx.save();\n      ctx.transform(\n        sprite.interpolatedPosition[0],\n        sprite.interpolatedPosition[1],\n        sprite.interpolatedPosition[2],\n        sprite.interpolatedPosition[3],\n        sprite.interpolatedPosition[4],\n        sprite.interpolatedPosition[5],\n      );\n      ctx.globalAlpha *= sprite.interpolatedAlpha;\n      sprite.render(ctx);\n      ctx.restore();\n    }\n  }\n\n  public skipAnimation(now: number): boolean {\n    let result: boolean = super.skipAnimation(now);\n    for (const sprite of this.sprites) {\n      result = sprite.skipAnimation(now) || result;\n    }\n    return result;\n  }\n}\n\nexport interface ILoadPanelProps extends IPanelProps {\n\n}\n","import {IAudio, IAudioProps, ISoundSpriteSheet, PlayState } from \"../util\";\n\nexport interface ISFX extends IAudio {\n  loop: false; // it will always be false\n}\n\nexport interface ISFXProps extends IAudioProps {\n}\n\nexport interface ILoadSFXProps {\n  name: string;\n  texture: string;\n}\n\nexport class SFXSprite implements ISFX {\n\n  // fields from IPlayable\n  public started: number = 0;\n  public length: number = 0;\n  public start: number = 0;\n  public end: number = 0;\n  public loop: false = false;\n  public state: PlayState = PlayState.Stopped; // unused\n  public loaded: Promise<void>;\n\n  // fields from IAudio\n  public gain: GainNode;\n  public source: AudioBuffer;\n  public destination: AudioNode;\n  public definition: ISoundSpriteSheet;\n  public context: AudioContext;\n  /**\n   * 1. sets all relevant metadata properties from spritesheet\n   * 2. creates gain node from context\n   * 3. set this.loaded to result of createSource(props.source, props.context);\n   * 4. set this.destination\n   */\n  constructor(props: ISFXProps) {\n    // TODO: 1\n    this.context = props.context;\n    this.definition = props.definition;\n    this.start = this.definition.spritemap[props.texture].start;\n    this.end = this.definition.spritemap[props.texture].end;\n    this.length = this.end - this.start;\n    this.gain = props.context.createGain();\n    this.loaded = this.createSource(props.source, props.context);\n    this.destination = props.context.destination;\n  }\n\n  // calls this.loaded.then(e => this.createPlayInstance());\n  public play(): this {\n    this.loaded.then(e => this.createPlayInstance());\n    return this;\n  }\n\n  // no ops\n  public stop(): this {\n    return this;\n  }\n  public pause(): this {\n    return this;\n  }\n\n  // sets the gainNode.gain.value property\n  // accepts [0..1]\n  public setVolume(volume: number): this {\n    if (volume < 0 || volume > 1) {\n      throw new Error(`setVolume() accepts a number between 0 and 1; got ${volume}.`);\n    }\n    this.gain.gain.value = volume;\n    return this;\n  }\n\n  /**\n   * 1. resolves response to arrayBuffer\n   * 2. creates audioBuffer\n   * 3. creates AudioBufferSourceNode\n   * 4. sets source property\n   */\n  private async createSource(res: Promise<Response>, context: AudioContext): Promise<void> {\n    const resp: Response = await res;\n    const buffer = await resp.arrayBuffer();\n    this.source = await context.decodeAudioData(buffer);\n  }\n\n  /**\n   * 1. creates new AudioBufferSourceNode\n   * 2. set node.buffer = this.source\n   * 3. set source metadata\n   * 4. connect node to destination\n   * 5. call start(0, offset, duration)\n   * 6. listen to ended event (look up the event)\n   * 7. clean up audio source node and disconnect it from the destination\n   */\n  private createPlayInstance(): void {\n    const node = this.context.createBufferSource();\n    node.buffer = this.source;\n    node.loop = this.loop; // false\n    // TODO: 3\n    node.connect(this.gain);\n\n    const now = Date.now();\n    node.start(0, this.start, this.length);\n\n    const gain = this.gain; // must be accessed inside of named function\n    node.addEventListener(\"ended\", function callback(e) {\n      node.disconnect(gain);\n      node.removeEventListener(\"ended\", callback);\n    });\n  }\n}\n","import assert from \"assert\";\nimport { createTextureMap, IInteractionPoint, ITextureMap, loadImage } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nexport interface ISlider extends ISprite {\n  value: number;\n  max: number;\n  min: number;\n  width: number;\n}\n\nexport interface ISliderProps extends ISpriteProps {\n  value?: number;\n  max?: number;\n  min?: number;\n  width: number;\n}\n\nexport class Slider extends Sprite implements ISlider {\n  public value: number = 0;\n  public max: number = 1;\n  public min: number = 0;\n  public width: number = 100;\n\n  private sliderPattern: CanvasPattern = null;\n  private pillTexture: ImageBitmap = null;\n\n  constructor(props: ISliderProps) {\n    super(props);\n\n    this.height = props.textures.Pill_Hover.height;\n    this.width = props.width;\n    this.max = props.max || this.max;\n    this.min = props.min || this.min;\n    this.value = props.value || this.value;\n\n    this.sliderPattern = document\n      .createElement(\"canvas\")\n      .getContext(\"2d\")\n      // @ts-ignore: Dom Spec Outdated. ImageBitmap is acceptable parameter for createPattern.\n      .createPattern(props.textures.Line, \"repeat-x\");\n  }\n\n  public broadPhase(point: IInteractionPoint): boolean {\n    if (this.active) {\n      return true;\n    }\n    return super.broadPhase(point);\n  }\n\n  public narrowPhase(point: IInteractionPoint): ISprite {\n    if (this.active) {\n      return this;\n    }\n    const sliderDistance = this.width - this.textures.Pill_Hover.width;\n    const sliderValuePercent = (this.value - this.min) / (this.max - this.min);\n    const valueX = sliderDistance * sliderValuePercent;\n\n    if (point.ty <= this.textures.Pill_Hover.height\n        && point.ty >= 0\n        && point.tx >= valueX\n        && point.tx <= valueX + this.textures.Pill_Hover.width) {\n        return this;\n      }\n  }\n\n  public pointCollision(point: IInteractionPoint): boolean {\n    super.pointCollision(point);\n\n    if (this.active && point.active === this) {\n      const previousValue = this.value;\n      const sliderDistance = this.width - this.textures.Pill_Hover.width;\n      const trueTX = point.tx - this.textures.Pill_Hover.width * 0.5;\n      const clampedTX = Math.max(0, Math.min(trueTX, sliderDistance));\n      const range = this.max - this.min;\n\n      this.value = this.min + range * clampedTX / sliderDistance;\n      if (this.value !== previousValue) {\n        super.emit(\"value-change\", this);\n      }\n    }\n\n    return true;\n  }\n\n  public update(): void {\n    this.cursor = this.hover ? \"pointer\" : \"default\";\n    this.pillTexture = this.active\n      ? this.textures.Pill_Active\n      : (this.hover ? this.textures.Pill_Hover : this.textures.Pill);\n  }\n\n  public render(ctx: CanvasRenderingContext2D): void {\n    ctx.drawImage(this.textures.Line_Cap_Left, 0, 0);\n    ctx.drawImage(\n      this.textures.Line_Cap_Right,\n      this.width - this.textures.Line_Cap_Right.width,\n      0,\n    );\n    ctx.fillStyle = this.sliderPattern;\n    ctx.fillRect(\n      this.textures.Line_Cap_Left.width,\n      0,\n      this.width - this.textures.Line_Cap_Left.width - this.textures.Line_Cap_Right.width,\n      this.textures.Line.height,\n    );\n    const sliderDistance = this.width - this.textures.Pill_Hover.width;\n    const sliderValuePercent = (this.value - this.min) / (this.max - this.min);\n    const valueX = sliderDistance * sliderValuePercent;\n\n    ctx.drawImage(this.pillTexture, valueX, 0);\n  }\n}\n\nexport interface ILoadSliderProps extends ISliderProps {\n\n}\n","import { IContainer } from \"./Container\";\nimport { IInteractionManagerProps, InteractionManager } from \"./InteractionManager\";\nimport { ISprite } from \"./Sprite\";\n\nexport interface IStageProps extends IInteractionManagerProps {\n\n}\n\nexport interface IStage extends IContainer {\n  update(): this;\n  render(): this;\n  skipAnimations(): boolean;\n}\n\nexport class Stage extends InteractionManager implements IStage {\n  constructor(props: IStageProps) {\n    super(props);\n  }\n  public update(): this {\n    const now = Date.now();\n    let sprite: ISprite;\n\n    super.emit(\"pre-interpolate\");\n    for (sprite of this.sprites) {\n      sprite.interpolate(now);\n    }\n    super.emit(\"post-interpolate\");\n\n    super.emit(\"pre-hover-check\");\n    this.hoverCheck(now);\n    super.emit(\"post-hover-check\");\n\n    super.emit(\"pre-update\");\n    for (sprite of this.sprites) {\n      sprite.update();\n    }\n    super.emit(\"post-update\");\n\n    return this;\n  }\n\n  public render(): this {\n    super.emit(\"pre-render\");\n    let sprite: ISprite;\n    let pointer: boolean = false;\n    const ctx = this.ctx;\n\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    for (sprite of this.sprites) {\n      ctx.save();\n      ctx.setTransform(\n        sprite.interpolatedPosition[0],\n        sprite.interpolatedPosition[1],\n        sprite.interpolatedPosition[2],\n        sprite.interpolatedPosition[3],\n        sprite.interpolatedPosition[4],\n        sprite.interpolatedPosition[5],\n      );\n      ctx.globalAlpha = sprite.interpolatedPosition[6];\n      sprite.render(ctx);\n      ctx.restore();\n      pointer = pointer || (sprite.hover && sprite.cursor === \"pointer\");\n    }\n\n    this.canvas.style.cursor = pointer ? \"pointer\" : \"default\";\n\n    super.emit(\"post-render\");\n    return this;\n  }\n\n  public skipAnimations(): boolean {\n    const now = Date.now();\n    let result = false;\n    for (const sprite of this.sprites) {\n      if (sprite.skipAnimation(now)) {\n        result = true;\n      }\n    }\n    return result;\n  }\n}\n","import assert from \"assert\";\nimport { createTextureMap, IPadding, ITextureMap, loadImage, TextAlign, TextBaseline } from \"../util\";\nimport { ISprite, ISpriteProps, Sprite } from \"./Sprite\";\n\nconst tempctx = document.createElement(\"canvas\").getContext(\"2d\");\n\nexport interface ITextbox extends ISprite {\n  text: string;\n  textSpeed: number;\n  textIndex: number;\n  padding: IPadding;\n  fontSize: number;\n  font: string;\n  fontColor: string;\n  lineHeight: number;\n  textAlign: TextAlign;\n  textBaseline: TextBaseline;\n\n  setText(text: string): this;\n  appendText(text: string): this;\n}\n\nexport interface ITextboxProps extends ISpriteProps {\n  text?: string;\n  textSpeed?: number;\n  textIndex?: number;\n  textAlign?: TextAlign;\n  textBaseline?: TextBaseline;\n  padding?: IPadding;\n  fontSize?: number;\n  font?: string;\n  fontColor?: string;\n  lineHeight?: number;\n}\n\nexport class Textbox extends Sprite implements ITextbox {\n  private static regex: RegExp = /\\r\\n|\\r|\\n|[^\\t ]*[\\t ]?/g;\n\n  public text: string = \"\";\n  public textSpeed: number = 1;\n  public textIndex: number = 0;\n  public padding: IPadding = {\n    bottom: 5,\n    left: 5,\n    right: 5,\n    top: 5,\n  };\n  public fontSize: number = 12;\n  public font: string = \"monospace\";\n  public fontColor: string = \"black\";\n  public lineHeight: number = 16;\n  public textAlign: TextAlign = TextAlign.left;\n  public textBaseline: TextBaseline = TextBaseline.hanging;\n  private interpolatedText: string[] = [\"\"];\n\n  constructor(props: ITextboxProps) {\n    super(props);\n    this.text = props.text || this.text;\n    this.textSpeed = props.textSpeed || this.textSpeed;\n    if (props.hasOwnProperty(\"textIndex\")) {\n      this.textIndex = props.textIndex;\n    }\n    this.padding = props.padding || this.padding;\n    this.fontSize = props.fontSize || this.fontSize;\n    this.font = props.font || this.font;\n    this.fontColor = props.fontColor || this.fontColor;\n    this.lineHeight = props.lineHeight || this.lineHeight;\n\n    this.setTexture(\"Texture\");\n  }\n\n  public update() {\n    const maxWidth = this.texture.width - this.padding.left - this.padding.right;\n    this.textIndex = Math.min(this.text.length, this.textIndex + this.textSpeed);\n    const words = this.text.match(Textbox.regex);\n    this.interpolatedText = [\"\"];\n    const maxLines = (this.texture.height - this.padding.top - this.padding.bottom) / this.lineHeight;\n    let line: string = \"\";\n    let lineIndex: number = 0;\n    let measurement: TextMetrics;\n    let leftOver: number = this.textIndex;\n    tempctx.font = `${this.fontSize}px ${this.font}`;\n\n    for (const word of words) {\n\n      // If the next character is a newline, push a new line\n      if (word === \"\\n\" || word === \"\\r\\n\" || word === \"\\r\") {\n        this.interpolatedText.push(\"\");\n        leftOver -= word.length;\n        lineIndex += 1;\n        continue;\n      }\n\n      line = this.interpolatedText[lineIndex];\n\n      // If there are no more characters to push, break\n      if (leftOver === 0) {\n        break;\n      }\n\n      // If the line count is greater than the maximum number of lines, break\n      if ((lineIndex + 1) > maxLines) {\n        break;\n      }\n\n      // Test the word length\n      line += word;\n      measurement = tempctx.measureText(line);\n\n      // If the line overflows\n      if (measurement.width > maxWidth) {\n        lineIndex = this.interpolatedText.push(\"\") - 1;\n      }\n\n      this.interpolatedText[lineIndex] += word;\n      // Add the text to the screen\n\n      leftOver -= word.length;\n\n      if (leftOver < 0) {\n        this.interpolatedText[lineIndex] = this.interpolatedText[lineIndex].slice(0, leftOver);\n        break;\n      }\n      // Check to see if the word overFlows the animation\n    }\n  }\n\n  public render(ctx: CanvasRenderingContext2D) {\n    super.render(ctx);\n    const maxHeight = this.texture.height - this.padding.top;\n    let currentHeight = this.padding.top;\n\n    ctx.font = `${this.fontSize}px ${this.font}`;\n    ctx.fillStyle = this.fontColor;\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n\n    ctx.beginPath();\n    ctx.rect(\n      this.padding.left,\n      this.padding.bottom,\n      this.width - this.padding.right,\n      this.height - this.padding.top,\n    );\n    ctx.clip();\n    for (const line of this.interpolatedText) {\n      if (currentHeight + this.fontSize > maxHeight) {\n        break;\n      }\n\n      ctx.fillText(line, this.padding.left, currentHeight);\n      currentHeight += this.lineHeight;\n    }\n  }\n\n  public setText(text: string): this {\n    if (text.startsWith(this.text)) {\n      this.text = text;\n      return this;\n    }\n\n    this.text = text;\n    this.interpolatedText = [\"\"];\n    this.textIndex = 0;\n    return this;\n  }\n\n  public appendText(text: string): this {\n    this.text += text;\n    return this;\n  }\n\n  public skipAnimation(now: number): boolean {\n    const result: boolean = super.skipAnimation(now) && this.textIndex < this.text.length;\n    this.textIndex = this.text.length;\n    return result;\n  }\n}\n\nexport interface ILoadTextboxProps extends ITextboxProps {\n\n}\n"],"names":["PI","Math","TAU","inFunc","ratio","outFunc","inverse","easeLinear","easeInQuad","easeOutQuad","easeInOutQuad","inOut","easeInCub","easeOutCub","easeInOutCub","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeOutSin","sin","easeInSin","easeInOutSin","easeOutElastic","pow","p","easeInElastic","easeInOutElastic","value","immutable","this","Float64Array","Identity","Matrix","x","y","m","translate","scale","angle","rotate","skewX","skewY","props","transform","chain","reset","target","set","matrix","setMatrix","a","b","c","d","e","f","det","IdentityMatrix","cos","tan","pa","pb","pc","pd","pe","pf","ma","mb","mc","md","me","mf","point","tx","ty","source","i","length","TextAlign","TextBaseline","PlayState","points","points_1","tslib_1.__values","transformPoint","definition","img","textures","Promise","all","Object","entries","frames","map","_a","_b","desc","frame","_c","_d","_e","createImageBitmap","_f","w","h","left","right","z","src","fetch","blob","_super","_this","eases.easeLinear","Image","id","position","m.Identity","m.set","previousPosition","interpolatedPosition","hasOwnProperty","previousAlpha","alpha","interpolatedAlpha","loaded","loadTexture","resolve","tslib_1.__extends","Sprite","width","height","now","interpolate","m.transformPoint","broadPhase","narrowPhase","timespan","wait","ease","animationLength","animationStart","Date","key","Error","result","lastInterpolated","progress","j","m.inverse","parent","m.chain","texture","oldTexture","emit","ctx","drawImage","res","createTextureMap","EventEmitter","center","middle","selected","font","fontColor","fontSize","text","textAlign","textBaseline","Button","setTexture","active","hover","cursor","update","render","fillStyle","fillText","name","displayName","color","checked","Boolean","Checkbox","clicked","toggle","pointCollision","Close","audioContext","AudioContext","Container","sprite","sprites","includes","push","splice","indexOf","playables","captured","down","firstDown","type","event","listener","mouseDown","document","body","mouseUp","mouseMove","touchStart","touchEnd","touchMove","touchCancel","canvas","createElement","appendChild","getContext","hookEvents","addPoint","mousePoint","InteractionManager","events","forEach","addEventListener","removeEventListener","pointDown","pointUp","pointMove","touch","changedTouches","addTouchPoint","touchPointIndex","identifier","removeTouchPoint","pointCancel","hoveringSprite","rect","getBoundingClientRect","clientX","clientY","top","sort","zSort","isHovering","toString","removePoint","tempctx","start","hanging","Label","measureText","sortZ","Panel","collision","beginPath","clip","save","globalAlpha","restore","skipAnimation","Stopped","context","spritemap","end","gain","createGain","createSource","destination","SFXSprite","then","createPlayInstance","volume","arrayBuffer","buffer","decodeAudioData","node","createBufferSource","loop","connect","disconnect","callback","Pill_Hover","max","min","sliderPattern","createPattern","Line","Slider","valueX","previousValue","sliderDistance","clampedTX","pillTexture","Pill_Active","Pill","Line_Cap_Left","Line_Cap_Right","fillRect","Stage","hoverCheck","pointer","clearRect","setTransform","style","bottom","textSpeed","textIndex","padding","lineHeight","Textbox","maxWidth","words","match","regex","interpolatedText","maxLines","line","lineIndex","leftOver","words_1","word","slice","maxHeight","currentHeight","startsWith"],"mappings":"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"}